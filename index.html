<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CrocoCross - Endless Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="assets/favicon.png" type="image/png" />
  <!-- Planck.js (Box2D port) -->
  <script src="https://unpkg.com/planck@1.0.0/dist/planck.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #87CEEB;
      font-family: "Trebuchet MS", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      user-select: none;
      overscroll-behavior: none;
    }
    #game {
      display: block;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(#78c8ff, #bde1ff 60%, #e6f6ff 100%);
      outline: none;
      cursor: none; /* cleaner feel */
    }
    .overlay {
      position: absolute;
      left: 50%;
      top: 15%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.92);
      border: 4px solid #333;
      border-radius: 12px;
      padding: 18px 20px;
      min-width: 360px;
      color: #111;
      box-shadow: 0 8px 20px rgba(0,0,0,0.25);
    }
    .title {
      font-size: 28px;
      font-weight: 900;
      color: #222;
      text-align: center;
      margin: 6px 0 10px 0;
      text-shadow: 1px 2px 0 #fff;
    }
    .menu-btns {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    button {
      background: #ffce3a;
      border: 3px solid #333;
      border-radius: 10px;
      padding: 10px 16px;
      font-weight: 800;
      color: #222;
      cursor: pointer;
      transition: transform 0.07s ease, background 0.2s ease;
    }
    button:hover { background: #ffd75f; }
    .play-big:hover { background: #2EE66B; }
    button:active { filter: brightness(0.95); }
    button[disabled] { opacity: 0.5; cursor: not-allowed; filter: grayscale(0.2); }
    .caption {
      font-size: 13px;
      color: #333;
      text-align: center;
      margin-top: 6px;
    }
    .hud {
      position: absolute;
      left: 12px;
      top: 10px;
      font-weight: 900;
      color: #102a43;
      text-shadow: 0 2px 0 rgba(255,255,255,0.65);
      font-size: 16px;
      pointer-events: none;
    }
    .hud-right {
      position: absolute;
      right: 12px;
      top: 10px;
      font-weight: 900;
      color: #102a43;
      text-shadow: 0 2px 0 rgba(255,255,255,0.65);
      font-size: 16px;
      pointer-events: none;
    }
    .hud-center {
      position: absolute;
      left: 50%;
      top: 10px;
      transform: translateX(-50%);
      font-weight: 900;
      color: #102a43;
      text-shadow: 0 2px 0 rgba(255,255,255,0.65);
      font-size: 16px;
      pointer-events: none;
    }
    /* New cartoon HUD box (single block, top-left) */
    .hudbox {
      position: absolute;
      left: 12px;
      top: 10px;
      background: rgba(255,255,255,0.9);
      border: 4px solid #333;
      border-radius: 12px;
      padding: 8px 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      color: #102a43;
      font-weight: 900;
      pointer-events: none;
      min-width: 170px;
    }
    .hudbox .hudline {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      margin: 2px 0;
    }
    .hudbox .hudlabel {
      background: #ffce3a;
      border: 2px solid #333;
      border-radius: 8px;
      padding: 2px 6px;
      font-size: 12px;
      color: #222;
      text-shadow: 1px 1px 0 #fff;
    }
    /* Right-side HUD box for scores */
    .hudbox-right {
      position: absolute;
      right: 12px;
      top: 10px;
      left: auto;
    }
    /* Speed progress bar */
    .hudbar {
      width: 180px;
      height: 12px;
      background: #eee;
      border: 2px solid #333;
      border-radius: 8px;
      overflow: hidden;
      margin: 4px 2px 6px 2px;
    }
    .hudbar-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #82d6ff, #2eb3ff);
    }
    /* Flip popup (toast) */
    .flip-popup {
      position: absolute;
      left: 50%;
      top: 18%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.95);
      border: 4px solid #333;
      border-radius: 14px;
      padding: 8px 12px;
      color: #102a43;
      font-weight: 900;
      box-shadow: 0 8px 20px rgba(0,0,0,0.25);
      pointer-events: none;
      z-index: 7;
      transition: opacity 0.15s ease;
    }
    .leaderboard {
      width: 440px;
      margin: 0 auto;
      background: rgba(255,255,255,0.97);
      border: 3px solid #333;
      border-radius: 10px;
      padding: 10px;
      max-height: 60vh;
      overflow: auto;
    }
    .lb-row {
      display: grid;
      grid-template-columns: 1.3fr 1fr 1fr 1fr; /* Name | Distance | Flip | Total */
      gap: 8px;
      padding: 6px 0;
      border-bottom: 1px dashed #ccc;
      font-weight: 700;
      color: #333;
    }
    .lb-row.header {
      color: #000;
      text-transform: uppercase;
      border-bottom: 2px solid #333;
    }
    .hidden { display: none; }
    .center { text-align: center; }
    .small {
      font-size: 12px;
      color: #333;
    }
    #nameInput {
      display: block;
      width: 160px;
      font-size: 18px;
      margin: 8px auto;
      text-align: center;
      padding: 6px 8px;
      border: 3px solid #333;
      border-radius: 8px;
      font-weight: 800;
    }
    .kbd {
      display: inline-block;
      border: 2px solid #222;
      border-bottom-width: 4px;
      padding: 2px 6px;
      border-radius: 6px;
      background: #fff;
      margin: 0 3px;
      min-width: 20px;
      text-align: center;
      font-weight: 800;
    }
    .badge {
      display: inline-block;
      padding: 2px 6px;
      background: #44d07b;
      border: 2px solid #222;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 900;
      color: #102a43;
      vertical-align: middle;
    }

    /* Modern full-screen menu */
    .menu-screen {
      position: fixed;
      inset: 0;
      background-image: url('assets/img/crococross-bg.png');
      background-size: cover;
      background-position: center;
      z-index: 5;
    }
    .menu-screen.hidden { display: none; }
    .menu-scrim {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(0,0,0,0.25) 0%, rgba(0,0,0,0.35) 60%, rgba(0,0,0,0.45) 100%);
      pointer-events: none;
    }
    .menu-logo {
      position: absolute;
      left: calc(clamp(16px, 6vw, 64px) + 200px);
      top: clamp(16px, 5vh, 56px);
      width: clamp(180px, 24vw, 360px);
      height: auto;
      filter: drop-shadow(0 8px 18px rgba(0,0,0,0.5));
      user-select: none;
      pointer-events: none;
    }
    .play-big {
      position: absolute;
      left: 50%;
      top: 58%;
      transform: translate(-50%, -50%);
      font-size: clamp(20px, 3.2vw, 32px);
      padding: clamp(12px, 1.8vw, 18px) clamp(28px, 3vw, 36px);
      border-width: 5px;
      border-radius: 16px;
      background: #ffffff;
      box-shadow: 0 10px 24px rgba(0,0,0,0.35);
    }
    .leaderboard-side {
      position: absolute;
      right: clamp(16px, 3vw, 36px);
      top: 50%;
      transform: translateY(-50%);
      writing-mode: vertical-rl;
      text-orientation: mixed;
      letter-spacing: 1px;
      font-size: clamp(14px, 1.6vw, 18px);
      padding: 14px 10px;
      border-width: 4px;
      border-radius: 12px;
      background: #ffffffd0;
    }
    .controls-card {
      position: absolute;
      left: clamp(16px, 6vw, 64px);
      bottom: clamp(16px, 6vh, 64px);
      background: rgba(255,255,255,0.92);
      border: 4px solid #333;
      border-radius: 14px;
      padding: 12px 14px;
      color: #111;
      width: clamp(240px, 28vw, 420px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    }
    .controls-title {
      font-weight: 900;
      font-size: clamp(16px, 2vw, 20px);
      margin-bottom: 6px;
      color: #111;
      text-shadow: 1px 1px 0 #fff;
    }
    .controls-rows .row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 4px 0;
      font-weight: 800;
      color: #222;
      font-size: clamp(13px, 1.6vw, 16px);
    }
    .music-btn {
      background: #ffffff;
      border: 3px solid #333;
      border-radius: 10px;
      padding: 6px 10px;
      font-weight: 900;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    }
    .audio-card {
      position: absolute;
      left: auto !important;                /* override .controls-card left */
      right: clamp(16px, 6vw, 64px);
      bottom: clamp(16px, 6vh, 64px);
      width: clamp(220px, 26vw, 360px);
      background: rgba(255,255,255,0.92);
      border: 4px solid #333;
      border-radius: 14px;
      padding: 12px 14px;
      color: #111;
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
      z-index: 6;                           /* sit above the background art */
    }
    /* Responsive layout: stack Audio above Controls on narrow screens */
    @media (max-width: 1000px) {
      .controls-card {
        left: 50%;
        right: auto;
        transform: translateX(-50%);
        width: min(92vw, 460px);
        bottom: clamp(16px, 6vh, 64px);
      }
      .audio-card {
        left: 50% !important;
        right: auto;
        transform: translateX(-50%);
        width: min(90vw, 440px);
        bottom: calc(clamp(16px, 6vh, 64px) + 180px); /* place above controls */
      }
    }
    /* Pause modal overlay */
    .cc-modal.hidden{display:none}
    .cc-modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:9999}
    .cc-modal-card{min-width:320px;padding:20px 24px;border-radius:14px;background:#fff;box-shadow:0 10px 30px rgba(0,0,0,.25);text-align:center}
    .cc-modal-actions button{margin:8px;padding:10px 16px;font-weight:600}
    /* Explosion FX overlay */
    #explosionFx {
      position: absolute;
      left: 0;
      top: 0;
      transform: translate(-50%, -50%);
      pointer-events: none;
      display: none;
      z-index: 4; /* above canvas, below menus (menu z-index:5) */
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <canvas id="game" width="1280" height="720"></canvas>
  <img id="explosionFx" src="assets/img/explosion1.gif" alt="Explosion" />

  <div id="menu" class="menu-screen">
    <img src="assets/img/crococross-logo.png" alt="CrocoCross" class="menu-logo" />
    <button id="playBtn" class="play-big">Play</button>
    <button id="leaderboardBtn" class="leaderboard-side">Leaderboard</button>
    <div class="controls-card">
      <div class="controls-title">Controls</div>
      <div class="controls-rows">
        <div class="row"><span class="kbd">→</span><span>Accelerate / Tilt forward (air)</span></div>
        <div class="row"><span class="kbd">←</span><span>Brake/Reverse / Tilt back (air)</span></div>
        <div class="row"><span class="kbd">Esc</span><span>Pause</span></div>
      </div>
    </div>
    <div id="audioCard" class="controls-card audio-card">
      <div class="controls-title">Audio</div>
      <div class="controls-rows">
        <div class="row"><span class="badge">Engine</span><button id="engineBtn" type="button" class="music-btn">Engine: ON</button></div>
        <div class="row"><span class="badge">Music</span><button id="musicBtn" type="button" class="music-btn">Music: Off</button></div>
      </div>
    </div>
  </div>

  <div id="leaderboardView" class="overlay hidden">
    <div class="title">Leaderboard</div>
    <div class="leaderboard" id="leaderboardList">
      <!-- rows injected -->
    </div>
    <div class="menu-btns">
      <button id="lbBackBtn">Back</button>
    </div>
  </div>

  <div id="gameOver" class="overlay hidden">
    <div class="title">Game Over</div>
    <div class="center" id="finalScoreText">Score: 0 m</div>
    <div id="namePrompt" class="center hidden">
      <div class="small">New high score! Enter initials (3):</div>
      <input type="text" id="nameInput" maxlength="3" placeholder="AAA" />
    </div>
    <div class="menu-btns">
      <button id="saveScoreBtn" class="hidden" disabled>Save Score</button>
    </div>
  </div>

  <div id="pauseModal" class="cc-modal hidden" aria-hidden="true">
    <div class="cc-modal-card">
      <h2>Paused</h2>
      <div class="cc-modal-actions">
        <button id="ccPauseHome">Home</button>
        <button id="ccPauseRestart">Restart</button>
        <button id="ccPauseContinue">Continue (Esc)</button>
      </div>
    </div>
  </div>

  <div id="hudBox" class="hudbox">
    <div class="hudline"><span class="hudlabel">Speed</span><span id="hudSpeed">0 km/h</span></div>
    <div class="hudbar" id="hudSpeedBar"><div class="hudbar-fill" id="hudSpeedFill" style="width: 0%"></div></div>
    <div class="hudline"><span class="hudlabel">Lives</span><span id="hudLives"></span></div>
  </div>

  <div id="scoreBox" class="hudbox hudbox-right">
    <div class="hudline"><span class="hudlabel">Distance</span><span id="scoreDist">0</span></div>
    <div class="hudline"><span class="hudlabel">Flip</span><span id="scoreFlip">0</span></div>
    <div class="hudline"><span class="hudlabel">Total</span><span id="scoreTotal">0</span></div>
  </div>

  <div id="flipPopup" class="flip-popup" style="display: none; opacity: 0"></div>

<script>
(() => {
  'use strict';

  // Aliases for Planck
  const pl = planck;
  const Vec2 = pl.Vec2;

  // CONFIG - tunables in one place
  const CONFIG = {
    SCALE: 40,                        // px per meter
    GRAVITY: 9.81,                    // m/s^2
    FIXED_HZ: 60,                     // physics Hz
    CHUNK_LENGTH: 60,                 // meters per terrain chunk
    SAMPLE_DX: 1.2,                   // meter sampling step
    GROUND_THICK: 4,                  // line width for drawing contour
    GROUND_FRICTION: 1.2,
    GROUND_RESTITUTION: 0.0,

    BASELINE_Y: -20,                  // for ground fill (below the lowest terrain in chunk)

    MAX_LIVES: 5,
    CHECKPOINT_EVERY: 200,            // meters

    // Terrain noise
    NOISE: {
      base: -2.0,                     // average ground height (m)
      amp1: 1.8, freq1: 0.05,         // first octave (slightly stronger, longer wavelength)
      amp2: 0.9, freq2: 0.12,         // second octave
      amp3: 0.5, freq3: 0.25          // third octave
    },

    // Long downhill overlay (deterministic spans)
    DESCENT: {
      PROB: 0.16,          // chance at a chunk start to start a downhill
      LONG_PROB: 0.05,     // subset of starts become “very long”
      SLOPE_MIN: 0.03,     // minimal |slope| (tanθ) for the downhill bias
      SLOPE_MAX_FRAC: 0.6, // cap slope to a fraction of current difficulty.slopeMax
      LEN_MIN: 30, LEN_MAX: 80,        // meters (regular long)
      LLEN_MIN: 120, LLEN_MAX: 220,    // meters (very long)

      // Post-descent cooldown (compress only positive slopes for a short window)
      COOL_LEN_MIN: 20,                 // meters
      COOL_LEN_MAX: 60,                 // meters
      COOL_POS_FRAC: 0.35               // cap positive slope to 35% of normal inside cooldown
    },

    // Baseline + Relief model
    BASELINE: {
      LONG_PROB: 0.18,
      LEN_MIN: 60, LEN_MAX: 160,
      LLEN_MIN: 180, LLEN_MAX: 320,
      SLOPE_MIN: 0.004,
      SLOPE_MAX_FRAC: 0.45
    },
    RELIEF: {
      POS_SLOPE_FRAC: 0.5
    },

    // Difficulty progression
    SLOPE_MAX_START: 0.6,             // tan(theta) ~ slope (0.6 ~ 31 deg)
    SLOPE_MAX_END: 0.9,               // max slope later (~42 deg cap)
    HOLE_PROB_START: 0.10,            // early probability
    HOLE_PROB_END: 0.30,              // later probability
    HOLE_W_MIN: 4.5,
    HOLE_W_MAX_START: 7.0,
    HOLE_W_MAX_END: 10.0,
    HOLE_RUNUP_MIN: 7.0,              // (m)
    HOLE_LAND_MIN: 7.0,
    HOLE_RAMP_LEN: 6.0,               // meters of ramp shaping before hole
    HOLE_MIN_SPACING: 35.0,           // avoid back-to-back holes too close
    START_SAFE_UNTIL: 100.0,          // no holes before this X (m) from start
    START_FLAT_UNTIL: 8.0,           // short flat pad near start
    START_BLEND_LEN: 12.0,            // smooth blend; hills visible by ~20 m
    SEAM_BLEND_LEN: 6.0,             // meters to blend first points of each new chunk to previous end to avoid steps

    // Jump feasibility heuristic (caps hole width to what is realistically jumpable)
    SAFE_JUMP: {
      JUMP_SPEED_START: 7.0,          // m/s early game
      JUMP_SPEED_END: 12.0,           // m/s late game
      MIN_TAKEOFF_ANGLE: 0.17,        // radians (~10 deg)
      MAX_TAKEOFF_ANGLE: 0.61,        // radians (~35 deg)
      RUNUP_SLOPE_MAX: 0.25,          // tan(theta) ~ 0.25 (~14 deg)
      LANDING_SLOPE_MAX: 0.35,        // ~19 deg
      SAFETY_MARGIN: 1.2              // meters subtracted from theoretical range
    },
    // Checkpoint safety near lips and forward-ground availability
    CP_SAFE_FORWARD: 6.0,             // meters of solid ground required ahead of a checkpoint
    CP_LIP_MARGIN: 0.8,               // avoid placing directly on a hole lip (± margin)
    CP_SEARCH_RADIUS: 10.0,           // search window around nominal CP X
    CP_STEP: 0.5,                     // scan step while searching a safe CP spot

    // Decorative content (images) — counts per 60 m chunk
    DECOR: {
      treePerChunk: 2.0,
      rockPerChunk: 1.2,
      hayPerChunk: 0.6,
      minSpacing: 7.0,
      treeScaleMin: 0.9,
      treeScaleMax: 1.25,
      rockScaleMin: 0.85,
      rockScaleMax: 1.15,
      treeUnder: 2.0,
      rockUnder: 2.0,
      hayUnder: 2.0,
      sup1PerChunk: 2.0,
      sup2PerChunk: 2.0,
      rabbitUnder: 2.0,
      carUnder: 2.0,
      deerUnder: 2.0,
      topAnchorMin: -0.03,
      topAnchorMax: -0.01,
      underDepthMin: 1.8,
      underDepthMax: 3.5
    },

    // Image clouds (parallax)
    CLOUDS: {
      count: 6,
      parallax: 0.06,
      scaleMin: 0.5,
      scaleMax: 0.9
    },

    // Audio
    AUDIO: {
      default: 'off',        // 'music1' | 'music2' | 'off' (default OFF per spec)
      volume: 0.2
    },

    // Bike params
    BIKE: {
      CHASSIS: { w: 2.0, h: 0.5, density: 1.2, angularDamping: 0.5, friction: 0.7 },
      WHEEL:   { r: 0.45, density: 1.0, friction: 1.7, restitution: 0.0 },
      HELMET:  { r: 0.20 },
      HUBS:    { rearOffsetX: -0.75, frontOffsetX: 0.85, hubY: -0.30 },
      MOTOR: {
        // Clean, snappy, progressive drive params
        maxTorque: 90.0,
        speedLimit: 140.0,   // faster top speed
        ACCEL: 28.0,        // rad/s^2 forward build-up (per second)
        BRAKE: 26.0,        // rad/s^2 toward 0 when flipping
        EPS: 0.25,          // near-zero dead-band for flip detection
        epsNoBrake: 0.45,   // slack for “never brake on re-throttle”
        LAUNCH_TORQUE: 7.0, // softer torque < LAUNCH_SPEED (very gentle)
        LAUNCH_SPEED: 50.0    // soft-launch up to ~18 km/h
      },
      TILT: {
        SIGN: 1,            // Right = back (nose-up), Left = forward (nose-down). Flip to -1 if your build is inverted.
        BASE: 8.0,          // gentler initial “impulse” in air
        ACCEL: 70.0,        // slower build for smoother tilt
        MAX: 20.0,          // lower cap for smoother feel
        DECAY: 110.0,       // gentler release
        HYSTERESIS_MS: 80,  // a bit higher to avoid flicker near lips
        GROUND_SCALE: 0.0   // no tilt when grounded
      },
      CHASSIS_TILT_TORQUE: 40.0,
      SPRITE: {
        path: 'assets/img/crococross-player.png',
        widthMeters: 2.4,
        offsetX: 0.0,
        offsetY: -0.05,
        clipToChassis: false,
        show: true
      }
    },

    // Camera
    CAM: {
      lookAhead: 5.0,       // meters
      yLag: 0.08,           // 0..1
      xLag: 0.12,
      snapX: 50.0,          // meters; hard snap threshold in X
      snapY: 25.0,          // meters; hard snap threshold in Y
      groundPadBottom: 10.0 // meters extra below min Y for fills
    },

    // World shifting (avoid float drift)
    RECENTER_X: 3500.0,

    // Misc
    INVULN_TIME: 1.0,       // seconds after respawn
    DEBUG: false
  };

  // Respawn/Death VFX config
  CONFIG.RESPAWN = {
    EXPLOSION_MS: 2000,
    FADE_OUT_MS: 500,
    FADE_IN_MS: 1000,
    ABOVE_CHECKPOINT_M: 3.5
  };

  // Flip counting config (added outside of CONFIG to avoid touching existing object literal)
  CONFIG.SCORE = CONFIG.SCORE || {};
  CONFIG.SCORE.LOOPS = {
    INV_ON_DEG: 150,        // enter inverted cone
    INV_OFF_DEG: 130,       // exit inverted cone
    LAND_HYSTERESIS_MS: 50  // confirm both wheels ON before awarding
  };

  const RAD = Math.PI / 180;
  const INV_ON  = Math.cos(CONFIG.SCORE.LOOPS.INV_ON_DEG  * RAD); // ~ -0.866
  const INV_OFF = Math.cos(CONFIG.SCORE.LOOPS.INV_OFF_DEG * RAD); // ~ -0.643

  // HUD config
  CONFIG.HUD = CONFIG.HUD || { SPEED_MAX_KMH: 120, POPUP_MS: 3000 };

  // Downhill-only mode (optional). Enabled per request to force non-increasing terrain and allow infinite descent.
  CONFIG.DOWNHILL = CONFIG.DOWNHILL || {
    ENABLED: false,
    EPS: 0.0,              // non-increasing tolerance (0 -> allow flats, >0 -> strictly decreasing)
    RECENTER_Y: 2500.0,    // recenter threshold (absolute magnitude)
    TARGET_Y: -2.0,        // target bike Y after recenter
    DISABLE_HOLES: true    // simple: avoid hole lips that would create local up-ramps
  };

  // Rider sprite asset
  const riderImg = new Image();
  let riderLoaded = false;
  riderImg.onload = () => { riderLoaded = true; };
  riderImg.src = CONFIG.BIKE.SPRITE.path;

  // Decorative images
  const treeImg = new Image(); treeImg.src = 'assets/img/crococross-tree.png';
  const rockImg = new Image(); rockImg.src = 'assets/img/crococross-rock.png';
  const hayImg = new Image();  hayImg.src  = 'assets/img/crococross-foin.png';
  const sup1Img = new Image(); sup1Img.src = 'assets/img/crococross-supporter1.png';
  const sup2Img = new Image(); sup2Img.src = 'assets/img/crococross-supporter2.png';
  const rabbitImg = new Image(); rabbitImg.src = 'assets/img/crococross-rabbit.png';
  const carImg = new Image(); carImg.src = 'assets/img/crococross-car.png';
  const deerImg = new Image(); deerImg.src = 'assets/img/crococross-biche.png';
  const cloudImg = new Image(); cloudImg.src = 'assets/img/crococross-cloud.png';
  const cloud2Img = new Image(); cloud2Img.src = 'assets/img/crococross-cloud2.png';

  // Audio assets
  const tracks = {
    music1: new Audio('assets/audio/crococross-music-1.mp3'),
    music2: new Audio('assets/audio/crococross-music-2.mp3')
  };
  tracks.music1.loop = true; tracks.music2.loop = true;
  tracks.music1.volume = CONFIG.AUDIO.volume; tracks.music2.volume = CONFIG.AUDIO.volume;
  const MUSIC_KEY = 'cc_music';
  let musicMode = (localStorage.getItem(MUSIC_KEY) || CONFIG.AUDIO.default);
  let audioUnlocked = false;
  function updateMusicUI() {
    if (!musicBtn) return;
    const label = musicMode === 'music1' ? 'Music: 1' : musicMode === 'music2' ? 'Music: 2' : 'Music: Off';
    musicBtn.textContent = label;
  }
  function stopAllMusic() {
    Object.values(tracks).forEach(a => { try { a.pause(); a.currentTime = 0; } catch {} });
  }
  async function applyMusic() {
    localStorage.setItem(MUSIC_KEY, musicMode);
    updateMusicUI();
    stopAllMusic();
    if (musicMode === 'off') return;
    if (!audioUnlocked) return; // wait for user gesture
    try { await tracks[musicMode].play(); } catch {}
  }
  function toggleMusic() {
    musicMode = musicMode === 'music1' ? 'music2' : musicMode === 'music2' ? 'off' : 'music1';
    applyMusic();
  }
  function unlockAndPlay() {
    if (audioUnlocked) return applyMusic();
    audioUnlocked = true;
    applyMusic();
  }

  // Engine toggle (persisted)
  const ENGINE_KEY = 'cc_engine';
  let engineEnabled = ((localStorage.getItem(ENGINE_KEY) ?? 'on') !== 'off');

  function updateEngineUI() {
    if (!engineBtn) return;
    engineBtn.textContent = engineEnabled ? 'Engine: ON' : 'Engine: OFF';
  }
  async function applyEngine() {
    localStorage.setItem(ENGINE_KEY, engineEnabled ? 'on' : 'off');
    updateEngineUI();
    // Respect current state immediately
    if (!engineEnabled) {
      engineMuteImmediate();
      engineSuspendIfSafe();
      return;
    }
    // Enabling: make sure graph exists and context is running
    if (typeof window.initEngineAudio === 'function' && !EngineState) {
      try { await window.initEngineAudio(); } catch {}
    }
    engineResumeIfNeeded();
  }
  async function toggleEngine() {
    engineEnabled = !engineEnabled;
    if (engineEnabled && typeof window.initEngineAudio === 'function') {
      try { await window.initEngineAudio(); } catch {}
    }
    applyEngine();
  }

  // Procedural Engine Audio (Web Audio API, no assets)
  // Public API on window: initEngineAudio(), updateEngineAudio(dt, telem)
  // telem: { airborne:boolean, wAvg:number, motorTarget:number, axis:-1|0|+1, speed_mps?:number }
  let EngineAC = null;
  let EngineState = null;

  function makeDistCurve(amount = 6) {
    const n = 1024, curve = new Float32Array(n), k = amount;
    for (let i = 0; i < n; i++) {
      const x = i * 2 / n - 1;
      curve[i] = (1 + k) * x / (1 + k * Math.abs(x));
    }
    return curve;
  }

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  async function initEngineAudio() {
    try {
      if (EngineState) return;
      const AC = new (window.AudioContext || window.webkitAudioContext)();
      // Create nodes
      const osc1 = AC.createOscillator(); osc1.type = 'triangle';
      const osc2 = AC.createOscillator(); osc2.type = 'triangle'; osc2.detune.value = +5; // softer detune
      const oscSub = AC.createOscillator(); oscSub.type = 'sine';

      const subGain = AC.createGain(); subGain.gain.value = 0.03; // subtler body
      const lp = AC.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 800; lp.Q.value = 0.0001;
      const sh = AC.createWaveShaper(); sh.curve = makeDistCurve(2);
      const engGain = AC.createGain(); engGain.gain.value = 0.0;

      // Simple compressor for headroom
      const comp = AC.createDynamicsCompressor();
      comp.threshold.value = -20; comp.knee.value = 30; comp.ratio.value = 2.5;
      comp.attack.value = 0.01; comp.release.value = 0.20;

      // Wind layer (simple sine; can be replaced by noise later)
      const windOsc = AC.createOscillator(); windOsc.type = 'sine';
      const windGain = AC.createGain(); windGain.gain.value = 0.0;

      // Wiring
      // Engine: (osc1 + osc2 + sub) -> LP -> Shaper -> engGain
      osc1.connect(lp);
      osc2.connect(lp);
      oscSub.connect(subGain); subGain.connect(lp);
      lp.connect(sh); sh.connect(engGain);
      // Wind: windOsc -> windGain ->
      windOsc.connect(windGain);
      // Mixdown: (engGain + windGain) -> comp -> destination
      engGain.connect(comp);
      windGain.connect(comp);
      comp.connect(AC.destination);

      const now = AC.currentTime;
      osc1.start(now); osc2.start(now); oscSub.start(now);
      windOsc.start(now);

      EngineAC = AC;
      EngineState = {
        rpm: 1500,
        osc1, osc2, oscSub,
        subGain, lp, sh, engGain,
        windOsc, windGain
      };
      // expose for other modules
      window.EngineAudio = { initEngineAudio, updateEngineAudio, isReady: () => !!EngineState };
      // Attempt resume in case context was created in a gesture callback that still needs resume
      if (AC.state === 'suspended') { try { await AC.resume(); } catch {} }
    } catch (e) {
      console.warn('Engine audio init failed:', e);
    }
  }

  function updateEngineAudio(dt, telem) {
    if (!EngineState || !EngineAC) return;
    const AC = EngineAC;
    const S = EngineState;
    const { airborne, wAvg, motorTarget, axis, speed_mps = 0 } = telem || {};

    // RPM model
    const RPM_IDLE = 1500, RPM_RED = 9000;
    const wheelRpm = Math.abs(wAvg || 0) * 9.5493;
    let rpmTarget;

    if (airborne) {
      rpmTarget = clamp(Math.max(RPM_IDLE, Math.abs(motorTarget || 0) * 9.5493) * 1.12, RPM_IDLE, RPM_RED);
    } else if ((axis | 0) !== 0) {
      rpmTarget = clamp(Math.max(wheelRpm, Math.abs(motorTarget || 0) * 9.5493), RPM_IDLE, RPM_RED);
    } else {
      rpmTarget = RPM_IDLE;
    }

    // One-pole smoothing
    const a = 1 - Math.exp(-dt / 0.09);
    S.rpm += (rpmTarget - S.rpm) * a;

    // Map RPM -> frequency
    const norm = clamp((S.rpm - RPM_IDLE) / (RPM_RED - RPM_IDLE), 0, 1);
    const f0 = 40 + 320 * norm;
    const t = AC.currentTime;
    S.osc1.frequency.setTargetAtTime(f0, t, 0.02);
    S.osc2.frequency.setTargetAtTime(f0, t, 0.02);
    S.oscSub.frequency.setTargetAtTime(f0 * 0.5, t, 0.02);

    // Loudness and filter opening
    const throttle = ((axis | 0) !== 0) ? 1 : 0;
    const vol = clamp(0.10 + 0.20 * throttle + 0.15 * norm, 0, 0.60) * (airborne ? 0.75 : 1.0);
    S.engGain.gain.setTargetAtTime(vol, t, 0.06);
    S.lp.frequency.setTargetAtTime(500 + 1400 * norm + (throttle ? 200 : 0), t, 0.08);

    // Wind gain by speed, slight bump in air
    const wVol = clamp(speed_mps * 0.008, 0, 0.18) + (airborne ? 0.03 : 0.0);
    S.windGain.gain.setTargetAtTime(wVol, t, 0.10);
    S.windOsc.frequency.setTargetAtTime(120 + 140 * norm, t, 0.05);
  }

  // Expose on window so UI/integration can call post-gesture
  window.initEngineAudio = initEngineAudio;
  window.updateEngineAudio = updateEngineAudio;

  // Engine audio helpers for lifecycle gating
  function engineMuteImmediate() {
    try {
      if (EngineState && EngineAC) {
        EngineState.engGain.gain.setValueAtTime(0, EngineAC.currentTime);
      }
    } catch {}
  }
  function engineSuspendIfSafe() {
    try {
      if (EngineAC && EngineAC.state === 'running') EngineAC.suspend();
    } catch {}
  }
  function engineResumeIfNeeded() {
    try {
      if (EngineAC && EngineAC.state === 'suspended') EngineAC.resume();
    } catch {}
  }

  // Collision categories
  const CAT = {
    GROUND: 0x0001,
    BIKE:   0x0002,
    HELMET: 0x0004
  };

  // UI elements
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let VIEW_W = window.innerWidth;
  let VIEW_H = window.innerHeight;
  const hudBox = document.getElementById('hudBox');
  const hudSpeed = document.getElementById('hudSpeed');
  const hudLives = document.getElementById('hudLives');
  const hudSpeedFill = document.getElementById('hudSpeedFill');
  const scoreDistEl = document.getElementById('scoreDist');
  const scoreFlipEl = document.getElementById('scoreFlip');
  const scoreTotalEl = document.getElementById('scoreTotal');
  const flipPopup = document.getElementById('flipPopup');
  const musicBtn = document.getElementById('musicBtn');
  const engineBtn = document.getElementById('engineBtn');
  let explosionFx = document.getElementById('explosionFx');

  const menu = document.getElementById('menu');
  const playBtn = document.getElementById('playBtn');
  const leaderboardBtn = document.getElementById('leaderboardBtn');

  const leaderboardView = document.getElementById('leaderboardView');
  const leaderboardList = document.getElementById('leaderboardList');
  const lbBackBtn = document.getElementById('lbBackBtn');

  const gameOver = document.getElementById('gameOver');
  const finalScoreText = document.getElementById('finalScoreText');
  const namePrompt = document.getElementById('namePrompt');
  const nameInput = document.getElementById('nameInput');
  const saveScoreBtn = document.getElementById('saveScoreBtn');

  // Input
  const keys = { up: false, down: false, left: false, right: false, debug: false, pause: false };

  // RNG (seeded)
  function mulberry32(a) {
    return function() {
      a |= 0;
      a = a + 0x6D2B79F5 | 0;
      var t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function newSeed() {
    const arr = new Uint32Array(1);
    crypto.getRandomValues(arr);
    return arr[0] || 1; // avoid zero
  }

  // 1D Value noise with seeded randomness, smooth interpolation (quintic)
  class ValueNoise1D {
    constructor(seed) {
      this.seed = seed | 0;
      this.cache = new Map();
    }
    rint(i) {
      if (this.cache.has(i)) return this.cache.get(i);
      let x = (i ^ this.seed) | 0;
      x = (x ^ 0x27d4eb2d) >>> 0;
      x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
      const v = (x >>> 0) / 4294967295;
      const val = v * 2 - 1; // [-1,1]
      this.cache.set(i, val);
      return val;
    }
    smoothstep(t) {
      // 6t^5 - 15t^4 + 10t^3
      return t * t * t * (t * (t * 6 - 15) + 10);
    }
    sample(x, freq) {
      const xf = x * freq;
      const i0 = Math.floor(xf);
      const i1 = i0 + 1;
      const t = xf - i0;
      const s = this.smoothstep(t);
      const v0 = this.rint(i0);
      const v1 = this.rint(i1);
      return v0 * (1 - s) + v1 * s; // [-1,1]
    }
  }

  // Terrain generator
  class Terrain {
    constructor(world, seed) {
      this.world = world;
      this.seed = seed;
      this.noise = new ValueNoise1D(seed ^ 0x9e3779b9);
      this.rand = mulberry32(seed ^ 0xa5a5a5a5);
      this.chunks = []; // {xStart, xEnd, segments: [{body, pts}], gfx: [{pts, baseY}]}
      this.generatedToX = -CONFIG.CHUNK_LENGTH; // pre-generate one flat chunk to the left
      this.visibleFromX = -9999;

      this.checkpoints = []; // {x, y}
      this.nextCheckpointX = CONFIG.CHECKPOINT_EVERY;

      this.worldOffsetX = 0; // accumulated shift for score continuity
      this.lastHoleEnd = -1e9;
      this.recenterCount = 0;
      this.lastDrawRecenterCount = 0;

      // Downhill descent span state
      this.descentActive = false;
      this.descentStartX = 0;
      this.descentEndX   = 0;
      this.descentSlope  = 0;

      // Post-descent positive-slope cooldown state
      this.coolActive = false;
      this.coolStartX = 0;
      this.coolEndX   = 0;
      this.lastCoolPlanX = -1;

      // Monotone baseline state (piecewise linear)
      this.baseX = 0;
      this.baseY = CONFIG.NOISE.base;
      this.baseM = 0;
      this.baseXEnd = 0;

      // Seeded phases for sine-based height to guarantee visible hills
      this.phase1 = this.rand() * Math.PI * 2;
      this.phase2 = this.rand() * Math.PI * 2;
      this.phase3 = this.rand() * Math.PI * 2;
    }

    difficultyAt(distance) {
      const t = Math.min(distance / 1200, 1); // progress 0..1 over ~1.2km
      return {
        slopeMax: lerp(CONFIG.SLOPE_MAX_START, CONFIG.SLOPE_MAX_END, t),
        holeProb: lerp(CONFIG.HOLE_PROB_START, CONFIG.HOLE_PROB_END, t),
        holeWMax: lerp(CONFIG.HOLE_W_MAX_START, CONFIG.HOLE_W_MAX_END, t)
      };
    }

    // Monotone baseline (piecewise linear) helpers
    baselineEnsureCovering(x) {
      // Advance baseline segments so that [baseX, baseXEnd] covers x
      const BL = CONFIG.BASELINE || {};
      while (x >= this.baseXEnd) {
        // advance to end of current segment
        this.baseY = this.baseY + this.baseM * (this.baseXEnd - this.baseX);
        this.baseX = this.baseXEnd;

        // plan next segment deterministically from world seed and boundary
        const seedMix = (this.seed ^ 0x914c3f25 ^ (Math.floor(this.baseX * 6151) | 0)) >>> 0;
        const rng = mulberry32(seedMix || 1);

        const longOne = rng() < (BL.LONG_PROB ?? 0.18);
        const len = longOne
          ? lerp(BL.LLEN_MIN ?? 180, BL.LLEN_MAX ?? 320, rng())
          : lerp(BL.LEN_MIN  ?? 60,  BL.LEN_MAX  ?? 160, rng());

        const { slopeMax } = this.difficultyAt(this.baseX);
        const cap = slopeMax * (BL.SLOPE_MAX_FRAC ?? 0.45);
        const s = -lerp(BL.SLOPE_MIN ?? 0.004, cap, rng()); // non-positive

        this.baseM = isFinite(s) ? Math.min(0, s) : 0;
        this.baseXEnd = this.baseX + Math.max(1, len);
      }
    }

    baselineAt(x) {
      this.baselineEnsureCovering(x);
      return this.baseY + this.baseM * (x - this.baseX);
    }

    sampleHeight(x) {
      const n = CONFIG.NOISE;
      // Relief: sines + value-noise wobble (zero-mean)
      const f1 = 0.02;
      const f2 = 0.06;
      const f3 = 0.12;
      const ySine =
        n.amp1 * Math.sin((2 * Math.PI * f1) * x + this.phase1) +
        n.amp2 * Math.sin((2 * Math.PI * f2) * x + this.phase2) +
        n.amp3 * Math.sin((2 * Math.PI * f3) * x + this.phase3);

      const wobble =
        0.25 * this.noise.sample(x + 101.3, 0.3) +
        0.15 * this.noise.sample(x * 1.3 + 333.7, 0.55);

      // Baseline + relief
      return this.baselineAt(x) + ySine + wobble;
    }

    // Generate chunk starting at xStart
    generateChunk(xStart, playerDistance) {
      const length = CONFIG.CHUNK_LENGTH;
      const dx = CONFIG.SAMPLE_DX;
      const xEnd = xStart + length;
      const pts = [];
      let minY = Infinity;





      // sample heights
      const yFlat0 = this.sampleHeight(0);
      for (let x = xStart; x <= xEnd + 1e-6; x += dx) {
        let y = this.sampleHeight(x);
        // Only flatten for x in [0, START_FLAT_UNTIL], and blend in (0..START_FLAT_UNTIL+BLEND)
        if (x >= 0 && x <= CONFIG.START_FLAT_UNTIL) {
          y = yFlat0; // fully flat pad at start
        } else if (x > CONFIG.START_FLAT_UNTIL && x <= CONFIG.START_FLAT_UNTIL + CONFIG.START_BLEND_LEN) {
          const t = (x - CONFIG.START_FLAT_UNTIL) / CONFIG.START_BLEND_LEN;
          y = lerp(yFlat0, y, Math.max(0, Math.min(1, t))); // smooth blend to noise
          // prevent sudden drop right after the start area
          y = Math.max(y, yFlat0 - 0.2);
        }
        pts.push({ x, y });
        if (y < minY) minY = y;
      }

      // Seam-align the start of this chunk to the previous chunk to avoid vertical steps at seams
      if (this.chunks.length > 0) {
        const prev = this.chunks[this.chunks.length - 1];
        if (prev && prev.gfx && prev.gfx.length > 0) {
          const lastPts = prev.gfx[prev.gfx.length - 1].pts;
          if (lastPts && lastPts.length > 0) {
            const prevLastY = lastPts[lastPts.length - 1].y;
            const L = CONFIG.SEAM_BLEND_LEN;
            if (pts.length > 0) {
              // Force continuity at the seam
              pts[0].y = prevLastY;
              if (L > 0) {
                for (let i = 1; i < pts.length; i++) {
                  const dxLoc = pts[i].x - xStart;
                  if (dxLoc > L) break;
                  const t = Math.max(0, Math.min(1, dxLoc / L));
                  // blend from seam y to original sampled y
                  pts[i].y = lerp(prevLastY, pts[i].y, t);
                }
              }
            }
          }
        }
      }

      // Optionally carve a hole
      const diff = this.difficultyAt(xStart);
      const posScale = () =>
        (CONFIG.RELIEF && typeof CONFIG.RELIEF.POS_SLOPE_FRAC === 'number')
          ? CONFIG.RELIEF.POS_SLOPE_FRAC
          : 1.0;
      this.smoothAndClamp(pts, diff.slopeMax, !!(CONFIG.DOWNHILL && CONFIG.DOWNHILL.ENABLED), posScale);
      const canHole = (xStart >= CONFIG.START_SAFE_UNTIL) && ((xStart - this.lastHoleEnd) >= CONFIG.HOLE_MIN_SPACING); // delay holes and ensure spacing
      const allowHoles = !(CONFIG.DOWNHILL && CONFIG.DOWNHILL.ENABLED && CONFIG.DOWNHILL.DISABLE_HOLES === true);
      const makeHole = allowHoles && canHole && this.rand() < diff.holeProb;
      let holes = [];
      if (makeHole) {
        // Determine hole width
        const wMin = CONFIG.HOLE_W_MIN;
        const wMax = diff.holeWMax;
        const w = lerp(wMin, wMax, this.rand());

        // Pick a hole center that leaves runup and landing within this chunk
        const runup = CONFIG.HOLE_RUNUP_MIN;
        const land = CONFIG.HOLE_LAND_MIN;
        const margin = runup + land + w + 4;
        if (length > margin) {
          const holeStartX = lerp(xStart + runup + 2, xEnd - land - w - 2, this.rand());
          const holeEndX = holeStartX + w;

          // Validate slope around hole zone (avoid steep approach)
          const ok = this.validateHoleZone(pts, holeStartX, holeEndX, diff.slopeMax, runup, land);
          if (ok) {
            // Cap hole width by a physically feasible jump range at this location
            const tProg = Math.min(xStart / 1200, 1);
            const safe = this.safeGapMax(pts, holeStartX, holeEndX, tProg);
            if (safe <= CONFIG.HOLE_W_MIN * 0.95) {
              // Too risky here; skip hole entirely
            } else {
              const adjEnd = holeStartX + Math.min(w, Math.max(CONFIG.HOLE_W_MIN, safe * 0.9));
              holes.push({ start: holeStartX, end: adjEnd });
              this.carveHole(pts, holeStartX, adjEnd, runup, land);
              this.smoothAndClamp(pts, diff.slopeMax, !!(CONFIG.DOWNHILL && CONFIG.DOWNHILL.ENABLED), posScale);
              this.lastHoleEnd = adjEnd;
            }
          }
        }
      }

      // Validate slope constraints globally (post-smoothing). If slightly over, clamp once more.
      if (!this.validateSlope(pts, diff.slopeMax)) {
        this.smoothAndClamp(pts, diff.slopeMax, !!(CONFIG.DOWNHILL && CONFIG.DOWNHILL.ENABLED), posScale);
      }

      // Split into contiguous ground segments excluding holes
      const segments = [];
      if (holes.length === 0) {
        segments.push(pts);
      } else {
        // carve holes
        let cur = [];
        for (let i = 0; i < pts.length; i++) {
          const p = pts[i];
          if (!pointInAnyHole(p.x, holes)) {
            cur.push(p);
          } else {
            if (cur.length >= 2) segments.push(cur);
            cur = [];
          }
        }
        if (cur.length >= 2) segments.push(cur);
        // ensure segment endpoints sit at hole edges (cleaner physics)
        // Already good enough for chain edges.
      }

      // Create physics bodies for each segment
      const segBodies = [];
      for (const seg of segments) {
        if (seg.length < 2) continue;
        const body = this.world.createBody();
        const vertices = seg.map(p => Vec2(p.x, p.y));
        const shape = pl.Chain(vertices, false); // open chain
        const fix = body.createFixture(shape, {
          friction: CONFIG.GROUND_FRICTION,
          restitution: CONFIG.GROUND_RESTITUTION,
          filterCategoryBits: CAT.GROUND,
          filterMaskBits: 0xFFFF,
        });
        fix.setUserData({ type: 'ground' });
        segBodies.push({ body, pts: seg });
      }

      // Gfx info (store pts and baseY)
      const gfx = segments.map(seg => {
        let localMin = Infinity;
        for (const p of seg) if (p.y < localMin) localMin = p.y;
        const baseY = Math.min(localMin - 6, CONFIG.BASELINE_Y);
        return { pts: seg, baseY };
      });

      const chunk = {
        xStart, xEnd, segments: segBodies, gfx, holes,
      };

      // Place checkpoints that fall within this chunk
      this.placeCheckpointsInChunk(chunk);

      this.chunks.push(chunk);
      this.generatedToX = Math.max(this.generatedToX, xEnd);
      return chunk;

      function pointInAnyHole(x, holes) {
        for (const h of holes) if (x >= h.start && x <= h.end) return true;
        return false;
      }
    }

    validateSlope(pts, slopeMax) {
      for (let i = 1; i < pts.length; i++) {
        const dx = pts[i].x - pts[i - 1].x;
        const dy = pts[i].y - pts[i - 1].y;
        if (dx <= 0) continue;
        const slope = Math.abs(dy / dx);
        if (slope > slopeMax) return false;
        // also enforce max vertical step
        if (Math.abs(dy) > 2.0) return false;
      }
      return true;
    }

    // Smooth and clamp sampled heights to keep slopes playable
    // downhillOnly: optional non-increasing enforcement (currently disabled by default)
    // posScaleAtX: optional function (x) -> [0..1] scaling for positive slope cap
    smoothAndClamp(pts, slopeMax, downhillOnly = false, posScaleAtX /* optional */) {
      if (!pts || pts.length < 2) return;
      const maxDy = slopeMax * CONFIG.SAMPLE_DX;
      const stepMax = 1.2; // hard cap per segment jump (m)
      const eps = (CONFIG.DOWNHILL && typeof CONFIG.DOWNHILL.EPS === 'number') ? CONFIG.DOWNHILL.EPS : 0.0;
      const maxDrop = Math.min(stepMax, maxDy);

      // forward pass (left -> right) — where we cap positive slopes with posScale
      let prev = pts[0].y;
      for (let i = 1; i < pts.length; i++) {
        let y = pts[i].y;
        const x = pts[i].x;

        // slope vs previous
        let dy = y - prev;

        // Positive-slope compression inside cooldown
        const posScale = (typeof posScaleAtX === 'function') ? Math.max(0, Math.min(1, posScaleAtX(x))) : 1.0;
        const posCap = maxDy * posScale;

        if (dy > posCap) y = prev + posCap;
        else if (dy < -maxDy) y = prev - maxDy;

        // step caps
        dy = y - prev;
        if (dy > stepMax) y = prev + stepMax;
        if (dy < -stepMax) y = prev - stepMax;

        // light smoothing
        y = 0.75 * y + 0.25 * prev;

        if (downhillOnly) {
          // enforce non-increasing and respect max drop
          y = Math.min(y, prev - eps);
          y = Math.max(y, prev - maxDrop);
        }

        pts[i].y = y;
        prev = y;
      }

      // backward pass (right -> left) — keep standard clamps; forward pass already tames positive climbs
      prev = pts[pts.length - 1].y;
      for (let i = pts.length - 2; i >= 0; i--) {
        let y = pts[i].y;
        let dy = y - prev;
        if (dy > maxDy) y = prev + maxDy;
        else if (dy < -maxDy) y = prev - maxDy;

        if (dy > stepMax) y = prev + stepMax;
        if (dy < -stepMax) y = prev - stepMax;

        y = 0.75 * y + 0.25 * prev;

        if (downhillOnly) {
          // y[left] >= y[right] to keep non-increasing globally
          y = Math.max(y, prev);
        }

        pts[i].y = y;
        prev = y;
      }
    }

    // Shape a gentle ramp before the hole and a small settle after landing
    carveHole(pts, startX, endX, runup, land) {
      const L = CONFIG.HOLE_RAMP_LEN;
      const rampRaise = 0.65; // meters raise at lip
      for (let i = 0; i < pts.length; i++) {
        const x = pts[i].x;
        // leading ramp: x in [startX - L, startX]
        if (x >= startX - L && x <= startX) {
          const t = (x - (startX - L)) / Math.max(1e-6, L); // 0..1
          pts[i].y += t * rampRaise;
        }
        // landing settle: flatten a bit for first 2 meters after end
        if (x > endX && x <= endX + 2.0) {
          // push slightly down to avoid a spike
          pts[i].y = Math.min(pts[i].y, pts[i - 1] ? pts[i - 1].y + 0.05 : pts[i].y);
        }
      }
    }

    validateHoleZone(pts, startX, endX, slopeMax, runup, land) {
      // ensure run-up before startX and landing after endX are gentle using stricter caps
      const runMax = Math.min(slopeMax, CONFIG.SAFE_JUMP.RUNUP_SLOPE_MAX);
      const landMax = Math.min(slopeMax, CONFIG.SAFE_JUMP.LANDING_SLOPE_MAX);
      const scan = (a, b, maxS) => {
        let prev = null;
        for (const p of pts) {
          if (p.x < a) continue;
          if (p.x > b) break;
          if (prev) {
            const dx = p.x - prev.x; if (dx <= 0) { prev = p; continue; }
            const dy = p.y - prev.y;
            const slope = Math.abs(dy / dx);
            if (slope > maxS) return false;
          }
          prev = p;
        }
        return true;
      };
      return scan(startX - runup, startX, runMax) && scan(endX, endX + land, landMax);
    }

    // Estimate maximum safe gap width given local takeoff/landing geometry and a plausible speed
    safeGapMax(pts, startX, endX, tProg) {
      const SJ = CONFIG.SAFE_JUMP;
      const g = CONFIG.GRAVITY;

      const yAt = (x) => {
        // linear interp in pts (monotonic in x)
        for (let i = 1; i < pts.length; i++) {
          const a = pts[i - 1], b = pts[i];
          if (x >= a.x && x <= b.x) {
            const t = (x - a.x) / Math.max(1e-6, (b.x - a.x));
            return a.y + (b.y - a.y) * t;
          }
        }
        // out of range: clamp to ends
        if (x < pts[0].x) return pts[0].y;
        return pts[pts.length - 1].y;
      };

      // Estimate takeoff angle using slope over a short window before the lip
      const win = 3.0; // meters
      const y0 = yAt(Math.max(startX - win, pts[0].x));
      const y1 = yAt(startX);
      const slope = (y1 - y0) / Math.max(1e-6, (startX - Math.max(startX - win, pts[0].x)));
      let theta = Math.atan(slope);
      theta = Math.max(SJ.MIN_TAKEOFF_ANGLE, Math.min(SJ.MAX_TAKEOFF_ANGLE, theta));

      // Check run-up and landing slopes with stricter bounds
      const runOk = this.validateHoleZone(pts, startX, endX, Number.POSITIVE_INFINITY, 8.0, 0.0);
      const landOk = this.validateHoleZone(pts, startX, endX, Number.POSITIVE_INFINITY, 0.0, 8.0);
      if (!runOk || !landOk) return 0;

      // Landing height just after the gap
      const yLanding = yAt(endX + 0.5);
      const drop = Math.max(0, y1 - yLanding); // positive if landing lower

      // Plausible speed progression
      const v = (SJ.JUMP_SPEED_START * (1 - tProg)) + (SJ.JUMP_SPEED_END * tProg);
      const vx = v * Math.cos(theta);
      const vy = v * Math.sin(theta);

      // Time of flight considering vertical offset between takeoff and landing
      let tFlight = 0;
      if (drop >= 0) {
        tFlight = (vy + Math.sqrt(vy * vy + 2 * g * drop)) / g;
      } else {
        const h = -drop; // landing higher
        const disc = vy * vy - 2 * g * h;
        if (disc <= 0) return 0;
        tFlight = (vy - Math.sqrt(disc)) / g;
        if (tFlight <= 0) return 0;
      }
      const range = Math.max(0, vx * tFlight);
      return Math.max(0, range - SJ.SAFETY_MARGIN);
    }

    placeCheckpointsInChunk(chunk) {
      while (this.nextCheckpointX <= chunk.xEnd) {
        if (this.nextCheckpointX >= chunk.xStart) {
          const pos = this.findSafePointNearX(chunk, this.nextCheckpointX);
          if (pos) {
            this.checkpoints.push(pos);
          } else {
            // fallback to direct height (if in a hole, nudge slightly right)
            const x = this.nextCheckpointX + 1.5;
            const y = this.sampleHeight(x) + 0.3;
            this.checkpoints.push({ x, y });
          }
        }
        this.nextCheckpointX += CONFIG.CHECKPOINT_EVERY;
      }
    }

    findSafePointNearX(chunk, x) {
      // Find a checkpoint point near x that is not inside a hole, not on a lip,
      // and has at least CP_SAFE_FORWARD meters of solid ground ahead.
      const holes = chunk.holes || [];
      const CPF = CONFIG.CP_SAFE_FORWARD;
      const LIP = CONFIG.CP_LIP_MARGIN;
      const R = CONFIG.CP_SEARCH_RADIUS;
      const STEP = CONFIG.CP_STEP;

      const yAt = (xp) => {
        // linear interpolate along gfx points
        for (const g of chunk.gfx) {
          const pts = g.pts;
          for (let i = 1; i < pts.length; i++) {
            const a = pts[i - 1], b = pts[i];
            if (xp >= a.x && xp <= b.x) {
              const t = (xp - a.x) / Math.max(1e-6, (b.x - a.x));
              return a.y + (b.y - a.y) * t;
            }
          }
        }
        // fallback to nearest point in this chunk
        let best = null, bestDx = 1e9;
        for (const g of chunk.gfx) {
          for (const p of g.pts) {
            const d = Math.abs(p.x - xp);
            if (d < bestDx) { bestDx = d; best = p; }
          }
        }
        return best ? best.y : this.sampleHeight(xp);
      };

      const isInHole = (xp) => {
        for (const h of holes) if (xp >= h.start && xp <= h.end) return true;
        return false;
      };
      const nearLip = (xp) => {
        for (const h of holes) if (Math.abs(xp - h.start) <= LIP) return true;
        return false;
      };
      const forwardSolidLen = (xp) => {
        let nextStart = Infinity;
        for (const h of holes) {
          if (h.start >= xp && h.start < nextStart) nextStart = h.start;
        }
        const toEnd = chunk.xEnd - xp;
        const toHole = (nextStart === Infinity) ? Infinity : (nextStart - xp);
        return Math.max(0, Math.min(toEnd, toHole));
      };

      const tryX = (xp) => {
        if (xp < chunk.xStart + 0.5 || xp > chunk.xEnd - 0.5) return null;
        if (isInHole(xp) || nearLip(xp)) return null;
        if (forwardSolidLen(xp) < CPF) return null;
        return { x: xp, y: yAt(xp) + 0.3 };
      };

      // Search left first (safer), then right
      for (let d = 0; d <= R + 1e-6; d += STEP) {
        const left = tryX(x - d);
        if (left) return left;
        if (d > 0) {
          const right = tryX(x + d);
          if (right) return right;
        }
      }
      // Fallback to nearest ground
      const y = yAt(x);
      return { x, y: y + 0.3 };
    }

    ensureAhead(targetX, playerDistance) {
      while (this.generatedToX < targetX) {
        // Attempt regeneration until non-null
        let tries = 0, chunk = null;
        do {
          chunk = this.generateChunk(this.generatedToX, playerDistance);
          tries++;
          if (tries > 8 && !chunk) break; // avoid infinite loop
        } while (!chunk);
        if (!chunk) {
          // fallback: flat chunk
          const flat = [];
          const dx = CONFIG.SAMPLE_DX;
          const xStart = this.generatedToX;
          const xEnd = xStart + CONFIG.CHUNK_LENGTH;
          for (let x = xStart; x <= xEnd + 1e-6; x += dx) flat.push({ x, y: -2.0 });
          // Create physics
          const body = this.world.createBody();
          const vertices = flat.map(p => Vec2(p.x, p.y));
          const shape = pl.Chain(vertices, false);
          const fix = body.createFixture(shape, {
            friction: CONFIG.GROUND_FRICTION,
            restitution: CONFIG.GROUND_RESTITUTION,
            filterCategoryBits: CAT.GROUND,
            filterMaskBits: 0xFFFF
          });
          fix.setUserData({ type: 'ground' });
          const baseY = -6;
          const chunkFallback = {
            xStart, xEnd, segments: [{ body, pts: flat }], gfx: [{ pts: flat, baseY }], holes: []
          };
          this.chunks.push(chunkFallback);
          this.placeCheckpointsInChunk(chunkFallback);
          this.generatedToX = xEnd;
        }
      }
    }

    cullBehind(minXToKeep, protectXOpt) {
      // keep also the chunk that contains the last PASSED checkpoint (if provided)
      const protectX = (typeof protectXOpt === 'number') ? (protectXOpt - 2) : -9999;

      for (let i = 0; i < this.chunks.length; i++) {
        const ch = this.chunks[i];
        const pad = CONFIG.CHUNK_LENGTH;
        const keep = (ch.xEnd >= (minXToKeep - pad)) || (protectX >= ch.xStart && protectX <= ch.xEnd);
        if (!keep) {
          // destroy bodies
          for (const s of ch.segments) {
            this.world.destroyBody(s.body);
          }
          this.chunks.splice(i, 1);
          i--;
        }
      }
    }

    lastCheckpoint() {
      return this.checkpoints.length ? this.checkpoints[this.checkpoints.length - 1] : null;
    }

    shiftWorldIfNeeded(bikeX, onShift) {
      if (bikeX >= CONFIG.RECENTER_X) {
        // Move world so that the bike returns near x ~ 10
        // Box2D/Planck shifts bodies by subtracting the vector passed to shiftOrigin.
        // To get newBikeX = 10, we need to subtract (bikeX - 10) from all bodies.
        const s = (bikeX - 10);
        const v = Vec2(s, 0);
        this.world.shiftOrigin(v); // bodies newPos = oldPos - s

        // Update stored coordinates with the SAME delta applied to bodies: subtract s
        for (const ch of this.chunks) {
          ch.xStart -= s;
          ch.xEnd  -= s;
          for (const seg of ch.segments) {
            for (const p of seg.pts) { p.x -= s; }
          }
          for (const g of ch.gfx) {
            for (const p of g.pts) { p.x -= s; }
          }
          for (const h of (ch.holes || [])) { h.start -= s; h.end -= s; }
          // Rebuild visual data after shift to avoid stale paths
          delete ch.decorUnder;
          delete ch.decorTop;
          this.rebuildGfx(ch);
        }
        for (const cp of this.checkpoints) { cp.x -= s; }
        // Shift baseline segment coordinates to maintain continuity
        this.baseX -= s;
        this.baseXEnd -= s;
        this.recomputeBoundsAfterShift();

        // Keep absolute score continuous: absX = worldOffsetX + bikeX (new bikeX ~ 10)
        this.worldOffsetX += s;

        // Ensure coverage around rider using NEW local coordinates (bike ~ 10 after shift)
        const localTarget = 10 + CONFIG.CHUNK_LENGTH;
        this.ensureAhead(localTarget, this.worldOffsetX + 10);

        // Visual safety: if no gfx covers the local rider span yet, rebuild and extend ahead once more.
        if (!this.hasGfxNear(10, CONFIG.CHUNK_LENGTH)) {
          for (const ch of this.chunks) this.rebuildGfx(ch);
          this.ensureAhead(10 + 2 * CONFIG.CHUNK_LENGTH, this.worldOffsetX + 10);
        }

        // Count recenters (for debug)
        this.recenterCount++;

        // Notify applied delta to camera/users as the delta bodies experienced: -s
        onShift && onShift(-s);
      }
    }

    // Vertical recentering for infinite downward terrain
    shiftWorldYIfNeeded(bikeY, onShiftY) {
      const DH = CONFIG.DOWNHILL || {};
      if (!DH.ENABLED) return;
      const recY = (typeof DH.RECENTER_Y === 'number') ? DH.RECENTER_Y : 2500.0;
      const targetY = (typeof DH.TARGET_Y === 'number') ? DH.TARGET_Y : -2.0;
      if (bikeY <= -recY) {
        // To get newBikeY = targetY, subtract (bikeY - targetY) from all bodies.
        const sy = (bikeY - targetY);
        const v = Vec2(0, sy);
        this.world.shiftOrigin(v); // bodies newPos = oldPos - sy

        // Update stored coordinates with the SAME delta applied to bodies: subtract sy
        for (const ch of this.chunks) {
          for (const seg of ch.segments) {
            for (const p of seg.pts) { p.y -= sy; }
          }
          for (const g of ch.gfx) {
            for (const p of g.pts) { p.y -= sy; }
          }
          // Holes only carry X, nothing to adjust in Y.
          delete ch.decorUnder;
          delete ch.decorTop;
          this.rebuildGfx(ch);
        }
        for (const cp of this.checkpoints) { cp.y -= sy; }
        // Keep baseline consistent with vertical recenter
        this.baseY -= sy;

        this.recomputeBoundsAfterShift();
        // Notify applied delta to camera/users as the delta bodies experienced: -sy
        onShiftY && onShiftY(-sy);
      }
    }

    rebuildGfx(ch) {
      const gfx = [];
      for (const seg of ch.segments) {
        const src = seg.pts || [];
        // Sort by x to guarantee a valid polyline after shifts and seam edits
        const ptsSorted = src.slice().sort((a, b) => a.x - b.x);
        // Deduplicate nearly-equal x to avoid zero-length segments
        const pts = [];
        for (let i = 0; i < ptsSorted.length; i++) {
          const p = ptsSorted[i];
          if (i === 0 || Math.abs(p.x - ptsSorted[i - 1].x) > 1e-6) {
            pts.push({ x: p.x, y: p.y });
          }
        }
        if (pts.length < 2) continue;
        let localMin = Infinity;
        for (const p of pts) if (p.y < localMin) localMin = p.y;
        const baseY = Math.min(localMin - 6, CONFIG.BASELINE_Y);
        gfx.push({ pts, baseY });
      }
      ch.gfx = gfx;
    }

    rebuildAllGfx() {
      for (const ch of this.chunks) this.rebuildGfx(ch);
    }

    recomputeBoundsAfterShift() {
      let minStart = Infinity; let maxEnd = -Infinity;
      for (const ch of this.chunks) {
        if (ch.xStart < minStart) minStart = ch.xStart;
        if (ch.xEnd > maxEnd) maxEnd = ch.xEnd;
      }
      if (minStart !== Infinity) this.visibleFromX = minStart; // conservative
      if (maxEnd !== -Infinity) this.generatedToX = maxEnd;
    }

    hasGfxNear(x, span = 60) {
      const a = x - span, b = x + span;
      for (const ch of this.chunks) {
        const gx = ch.gfx || [];
        for (const g of gx) {
          const pts = g.pts || [];
          if (pts.length < 2) continue;
          const left = pts[0].x;
          const right = pts[pts.length - 1].x;
          if (right >= a && left <= b) return true;
        }
      }
      return false;
    }

    // Ensure per-chunk decorations exist (deterministic, no physics)
    ensureDecorations(chunk) {
      if (chunk.decorUnder && chunk.decorTop) return;
      const holes = chunk.holes || [];
      const inHole = (x) => {
        for (const h of holes) if (x >= h.start && x <= h.end) return true;
        return false;
      };
      const yAt = (xp) => {
        for (const g of chunk.gfx) {
          const pts = g.pts;
          for (let i = 1; i < pts.length; i++) {
            const a = pts[i - 1], b = pts[i];
            if (xp >= a.x && xp <= b.x) {
              const t = (xp - a.x) / Math.max(1e-6, (b.x - a.x));
              return a.y + (b.y - a.y) * t;
            }
          }
        }
        return this.sampleHeight(xp);
      };
      const decTop = [];
      const decUnder = [];
      const nearAny = (xx) => {
        for (const d of decTop) if (Math.abs(d.x - xx) < CONFIG.DECOR.minSpacing) return true;
        for (const d of decUnder) if (Math.abs(d.x - xx) < CONFIG.DECOR.minSpacing) return true;
        return false;
      };
      const pushUnderIfOk = (type, x, sMin, sMax, bury, rng) => {
        // small horizontal jitter for variety
        x += (rng() - 0.5) * 1.6;
        if (x <= chunk.xStart + 1 || x >= chunk.xEnd - 1) return;
        if (inHole(x)) return;
        if (nearAny(x)) return;
        const s = sMin + rng() * (sMax - sMin);
        // place below the ground line (in the green)
        const buryAmt = Math.abs(bury) * (0.6 + 0.8 * rng()); // 0.6..1.4 * bury
        const y = yAt(x) - buryAmt;
        decUnder.push({ type, layer: 'under', x, y, s, flip: rng() < 0.5 });
      };
      const pushTopIfOk = (type, x, sMin, sMax, rng) => {
        // small horizontal jitter for variety
        x += (rng() - 0.5) * 1.6;
        if (x <= chunk.xStart + 1 || x >= chunk.xEnd - 1) return;
        if (inHole(x)) return;
        if (nearAny(x)) return;
        const s = sMin + rng() * (sMax - sMin);
        // place slightly above the ground line (anchored on top)
        const apMin = CONFIG.DECOR.topAnchorMin || 0.04;
        const apMax = CONFIG.DECOR.topAnchorMax || 0.07;
        const y = yAt(x) + (apMin + rng() * Math.max(0.001, apMax - apMin));
        decTop.push({ type, layer: 'top', x, y, s, flip: rng() < 0.5 });
      };
      // Local deterministic RNG based on world seed and chunk start
      const seedMix = (this.seed ^ (Math.floor(chunk.xStart * 9973) | 0)) >>> 0;
      const rng = mulberry32(seedMix || 1);
      // TOP anchored (on the ridge): tree/rock/hay
      const tCount = Math.max(0, Math.round(CONFIG.DECOR.treePerChunk + (rng() - 0.5)));
      for (let i = 0; i < tCount; i++) {
        const x = chunk.xStart + 2 + rng() * Math.max(0, (chunk.xEnd - chunk.xStart - 4));
        pushTopIfOk('tree', x, CONFIG.DECOR.treeScaleMin, CONFIG.DECOR.treeScaleMax, rng);
      }
      const rCount = Math.max(0, Math.round(CONFIG.DECOR.rockPerChunk + (rng() - 0.5)));
      for (let i = 0; i < rCount; i++) {
        const x = chunk.xStart + 2 + rng() * Math.max(0, (chunk.xEnd - chunk.xStart - 4));
        pushTopIfOk('rock', x, CONFIG.DECOR.rockScaleMin, CONFIG.DECOR.rockScaleMax, rng);
      }
      const hCount = Math.max(0, Math.round((CONFIG.DECOR.hayPerChunk || 0) + (rng() - 0.5)));
      for (let i = 0; i < hCount; i++) {
        const x = chunk.xStart + 2 + rng() * Math.max(0, (chunk.xEnd - chunk.xStart - 4));
        pushTopIfOk('hay', x, 0.9, 1.15, rng);
      }

      // UNDER-FILL extras (placed deeper inside the green area)
      const uMin = CONFIG.DECOR.underDepthMin || 0.35;
      const uMax = CONFIG.DECOR.underDepthMax || 1.6;
      const depth = () => uMin + rng() * Math.max(0.01, (uMax - uMin));

      // Trees under
      const tu = Math.max(0, Math.round((CONFIG.DECOR.treeUnder || 0) + (rng() - 0.5)));
      for (let i = 0; i < tu; i++) {
        const x = chunk.xStart + 2 + rng() * Math.max(0, (chunk.xEnd - chunk.xStart - 4));
        pushUnderIfOk('tree', x, CONFIG.DECOR.treeScaleMin, CONFIG.DECOR.treeScaleMax, depth(), rng);
      }
      // Rocks under
      const ru = Math.max(0, Math.round((CONFIG.DECOR.rockUnder || 0) + (rng() - 0.5)));
      for (let i = 0; i < ru; i++) {
        const x = chunk.xStart + 2 + rng() * Math.max(0, (chunk.xEnd - chunk.xStart - 4));
        pushUnderIfOk('rock', x, CONFIG.DECOR.rockScaleMin, CONFIG.DECOR.rockScaleMax, depth(), rng);
      }
      // Hay under
      const hu = Math.max(0, Math.round((CONFIG.DECOR.hayUnder || 0) + (rng() - 0.5)));
      for (let i = 0; i < hu; i++) {
        const x = chunk.xStart + 2 + rng() * Math.max(0, (chunk.xEnd - chunk.xStart - 4));
        pushUnderIfOk('hay', x, 0.9, 1.15, depth(), rng);
      }
      // Supporters under only
      const s1 = Math.max(0, Math.round((CONFIG.DECOR.sup1PerChunk || 0) + (rng() - 0.5)));
      for (let i = 0; i < s1; i++) {
        const x = chunk.xStart + 2 + rng() * Math.max(0, (chunk.xEnd - chunk.xStart - 4));
        pushUnderIfOk('sup1', x, 0.9, 1.15, depth(), rng);
      }
      const s2 = Math.max(0, Math.round((CONFIG.DECOR.sup2PerChunk || 0) + (rng() - 0.5)));
      for (let i = 0; i < s2; i++) {
        const x = chunk.xStart + 2 + rng() * Math.max(0, (chunk.xEnd - chunk.xStart - 4));
        pushUnderIfOk('sup2', x, 0.9, 1.15, depth(), rng);
      }
      // Rabbits under
      const rb = Math.max(0, Math.round((CONFIG.DECOR.rabbitUnder || 0) + (rng() - 0.5)));
      for (let i = 0; i < rb; i++) {
        const x = chunk.xStart + 2 + rng() * Math.max(0, (chunk.xEnd - chunk.xStart - 4));
        pushUnderIfOk('rabbit', x, 0.95, 1.15, depth(), rng);
      }
      // Cars under
      const car = Math.max(0, Math.round((CONFIG.DECOR.carUnder || 0) + (rng() - 0.5)));
      for (let i = 0; i < car; i++) {
        const x = chunk.xStart + 2 + rng() * Math.max(0, (chunk.xEnd - chunk.xStart - 4));
        pushUnderIfOk('car', x, 0.95, 1.15, depth(), rng);
      }
      // Deer (biche) under
      const deer = Math.max(0, Math.round((CONFIG.DECOR.deerUnder || 0) + (rng() - 0.5)));
      for (let i = 0; i < deer; i++) {
        const x = chunk.xStart + 2 + rng() * Math.max(0, (chunk.xEnd - chunk.xStart - 4));
        pushUnderIfOk('deer', x, 0.95, 1.15, depth(), rng);
      }

      chunk.decorUnder = decUnder;
      chunk.decorTop = decTop;
    }

    draw(camera) {
      const scale = CONFIG.SCALE;
      // If a recenter occurred since last draw, rebuild all chunk gfx once (safest)
      if (this.lastDrawRecenterCount !== this.recenterCount) {
        for (const ch of this.chunks) this.rebuildGfx(ch);
        this.lastDrawRecenterCount = this.recenterCount;
      }
      // If for any reason no ground covers the camera span, attempt a lazy rebuild and ensure ahead.
      if (!this.hasGfxNear(camera.x, CONFIG.CHUNK_LENGTH) || (typeof bike !== 'undefined' && bike && !this.hasGfxNear(bike.getPos().x, CONFIG.CHUNK_LENGTH))) {
        for (const ch of this.chunks) this.rebuildAllGfx ? this.rebuildAllGfx() : this.rebuildGfx(ch);
        const refX = (typeof bike !== 'undefined' && bike) ? bike.getPos().x : camera.x;
        this.ensureAhead(refX + 2 * CONFIG.CHUNK_LENGTH, this.worldOffsetX + refX);
      }
      // Ground fill + stroke
      ctx.lineWidth = CONFIG.GROUND_THICK;
      ctx.strokeStyle = '#2e8b57'; // grass outline
      ctx.fillStyle = '#7cd37b';   // grass fill top

      for (const ch of this.chunks) {
        // Safety: if gfx got invalidated around a recenter, rebuild lazily
        if (!ch.gfx || !ch.gfx.length) this.rebuildGfx(ch);
        for (const g of ch.gfx) {
          const pts = g.pts;
          if (pts.length < 2) continue;

          // Decorations first so ground fill occludes their bases
          this.ensureDecorations(ch);
          if (false && ch.decor && ch.decor.length) {
            for (const d of ch.decor) {
              const img =
                d.type === 'tree' ? treeImg :
                d.type === 'rock' ? rockImg :
                d.type === 'hay'  ? hayImg  :
                d.type === 'sup1' ? sup1Img : sup2Img;
              if (!img.complete) continue;
              const sx = worldToScreenX(d.x, camera.x);
              const sy = worldToScreenY(d.y, camera.y);
              const baseWm = d.type === 'tree' ? 2.0 : (d.type === 'rock' ? 1.2 : (d.type === 'hay' ? 1.4 : 1.8));
              const w = baseWm * scale * d.s;
              const h = w * (img.height / Math.max(1, img.width));
              ctx.save();
              ctx.translate(sx, sy);
              ctx.scale(d.flip ? -1 : 1, 1);
              // Keep a bit of extra burial; ground fill drawn after will hide the base entirely
              const buryPad = (d.type === 'tree' ? 0.35 : (d.type === 'rock' ? 0.22 : (d.type === 'hay' ? 0.18 : 0.22))) * h;
              ctx.drawImage(img, -w * 0.5, -h + buryPad, w, h);
              ctx.restore();
            }
          }

          // Build path
          ctx.beginPath();
          // top contour
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            const sx = worldToScreenX(p.x, camera.x);
            const sy = worldToScreenY(p.y, camera.y);
            if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
          }
          // Close polygon to base (ensure fill extends below screen bottom)
          const last = pts[pts.length - 1];
          const first = pts[0];
          const worldH = VIEW_H / Math.max(1e-6, scale);
          const worldBottom = camera.y - worldH * 0.5 - (CONFIG.CAM.groundPadBottom || 0);
          const baseW = Math.min(getChunkBaseY(pts), worldBottom);
          const sxb = worldToScreenX(last.x, camera.x);
          const syb = worldToScreenY(baseW, camera.y);
          ctx.lineTo(sxb, syb);
          const sxf = worldToScreenX(first.x, camera.x);
          ctx.lineTo(sxf, syb);
          ctx.closePath();

          // Fill soil below grass with two-tone
          ctx.fillStyle = '#9b6f3a'; // soil
          ctx.fill();
          // Grass top strip
          ctx.save();
          ctx.clip();
          ctx.beginPath();
          // small strip above path
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            const sx = worldToScreenX(p.x, camera.x);
            const sy = worldToScreenY(p.y + 0.05, camera.y);
            if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
          }
          ctx.lineTo(sxb, syb);
          ctx.lineTo(sxf, syb);
          ctx.closePath();
          ctx.fillStyle = '#6fd97a';
          ctx.fill();
          ctx.restore();

          // Draw UNDER (in the green)
          if (ch.decorUnder && ch.decorUnder.length) {
            for (const d of ch.decorUnder) {
              const img =
                d.type === 'tree' ? treeImg :
                d.type === 'rock' ? rockImg :
                d.type === 'hay'  ? hayImg  :
                d.type === 'sup1' ? sup1Img :
                d.type === 'sup2' ? sup2Img :
                d.type === 'rabbit' ? rabbitImg :
                d.type === 'car' ? carImg :
                d.type === 'deer' ? ((deerImg && deerImg.naturalWidth > 0) ? deerImg : rabbitImg) : null;
              if (!img || !img.complete) continue;
              const sx = worldToScreenX(d.x, camera.x);
              const sy = worldToScreenY(d.y, camera.y);
              const baseWm =
                d.type === 'tree' ? 2.0 :
                d.type === 'rock' ? 1.2 :
                d.type === 'hay'  ? 1.4 :
                d.type === 'car'  ? 4.0 :
                d.type === 'deer' ? 1.6 :
                (d.type === 'sup1' || d.type === 'sup2') ? 2.4 : 1.2; // supporters 2x
              const w = baseWm * scale * d.s;
              const h = w * (img.height / Math.max(1, img.width));
              ctx.save();
              ctx.translate(sx, sy);
              ctx.scale(d.flip ? -1 : 1, 1);
              // deeper inside green (positive buryPad)
              const buryPad =
                (d.type === 'tree' ? 0.35 :
                 d.type === 'rock' ? 0.22 :
                 d.type === 'hay'  ? 0.18 :
                 d.type === 'car'  ? 0.22 : 0.20) * h;
              ctx.drawImage(img, -w * 0.5, -h + buryPad, w, h);
              ctx.restore();
            }
          }
          // Draw TOP (anchored on the ridge, then the lip/outline will pass over the base)
          if (ch.decorTop && ch.decorTop.length) {
            for (const d of ch.decorTop) {
              const img =
                d.type === 'tree' ? treeImg :
                d.type === 'rock' ? rockImg :
                d.type === 'hay'  ? hayImg : null;
              if (!img || !img.complete) continue;
              const sx = worldToScreenX(d.x, camera.x);
              const sy = worldToScreenY(d.y, camera.y);
              const baseWm = d.type === 'tree' ? 2.0 : (d.type === 'rock' ? 1.2 : 1.4);
              const w = baseWm * scale * d.s;
              const h = w * (img.height / Math.max(1, img.width));
              ctx.save();
              ctx.translate(sx, sy);
              ctx.scale(d.flip ? -1 : 1, 1);
              // slightly embedded in ridge (avoid floating, not too deep)
              const buryPadTop = 0.10 * h;
              ctx.drawImage(img, -w * 0.5, -h + buryPadTop, w, h);
              ctx.restore();
            }
          }

          // Draw a soft grass lip to bury decorations into the ground
          ctx.save();
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.strokeStyle = '#6fd97a';
          ctx.lineWidth = CONFIG.GROUND_THICK + 18; // thicker lip to cover bases
          ctx.beginPath();
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            const sx = worldToScreenX(p.x, camera.x);
            const sy = worldToScreenY(p.y, camera.y);
            if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
          }
          ctx.stroke();
          ctx.restore();

          // Outline
          ctx.beginPath();
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            const sx = worldToScreenX(p.x, camera.x);
            const sy = worldToScreenY(p.y, camera.y);
            if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
          }
          ctx.stroke();
        }
      }

      // Checkpoint flags
      for (const cp of this.checkpoints) {
        const sx = worldToScreenX(cp.x, camera.x);
        const sy = worldToScreenY(cp.y, camera.y);
        drawFlag(sx, sy);
      }

      // Debug draw
      if (CONFIG.DEBUG) {
        ctx.fillStyle = '#000';
        ctx.font = '10px monospace';
        for (const ch of this.chunks) {
          for (const g of ch.gfx) {
            for (let i = 1; i < g.pts.length; i++) {
              const a = g.pts[i - 1], b = g.pts[i];
              const dx = b.x - a.x, dy = b.y - a.y;
              const slope = (dy / dx);
              const sx = worldToScreenX((a.x + b.x) * 0.5, camera.x);
              const sy = worldToScreenY((a.y + b.y) * 0.5 + 0.5, camera.y);
              ctx.fillText(slope.toFixed(2), sx, sy);
            }
          }
        }
      }

      function getChunkBaseY(pts) {
        let minY = Infinity;
        for (const p of pts) if (p.y < minY) minY = p.y;
        return minY - 4;
      }
      function worldToScreenX(x, camX) {
        return Math.round(VIEW_W * 0.5 + (x - camX) * scale);
      }
      function worldToScreenY(y, camY) {
        return Math.round(VIEW_H * 0.5 - (y - camY) * scale);
      }
      function worldToScreenX(x, camX) {
        return Math.round(VIEW_W * 0.5 + (x - camX) * scale);
      }
      function worldToScreenY(y, camY) {
        return Math.round(VIEW_H * 0.5 - (y - camY) * scale);
      }
      function drawFlag(sx, sy) {
        ctx.save();
        // pole
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx, sy - 40);
        ctx.stroke();
        // flag
        ctx.fillStyle = '#ff3b3b';
        ctx.beginPath();
        ctx.moveTo(sx, sy - 40);
        ctx.lineTo(sx + 24, sy - 32);
        ctx.lineTo(sx, sy - 24);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }
  }

  // Bike model
  class Bike {
    constructor(world, spawnPos) {
      this.world = world;
      this.dead = false;
      this.invulnTimer = 0;

      const p = spawnPos || { x: 0, y: 0 };
      const B = CONFIG.BIKE;

      // Chassis
      const ch = world.createDynamicBody({
        position: Vec2(p.x, p.y + 0.6),
        angularDamping: B.CHASSIS.angularDamping,
      });
      ch.setBullet(true);
      const chassisShape = pl.Box(B.CHASSIS.w * 0.5, B.CHASSIS.h * 0.5);
      const cfix = ch.createFixture({
        shape: chassisShape,
        density: B.CHASSIS.density,
        friction: B.CHASSIS.friction,
        filterCategoryBits: CAT.BIKE,
        filterMaskBits: 0xFFFF ^ CAT.HELMET
      });
      cfix.setUserData({ type: 'chassis' });

      // Wheels
      const rw = world.createDynamicBody(Vec2(p.x + B.HUBS.rearOffsetX, p.y + B.HUBS.hubY));
      const fw = world.createDynamicBody(Vec2(p.x + B.HUBS.frontOffsetX, p.y + B.HUBS.hubY));
      rw.setBullet(true);
      fw.setBullet(true);
      const wheelShape = pl.Circle(B.WHEEL.r);
      const rwFix = rw.createFixture({ shape: wheelShape, density: B.WHEEL.density, friction: B.WHEEL.friction, restitution: B.WHEEL.restitution, filterCategoryBits: CAT.BIKE });
      const fwFix = fw.createFixture({ shape: wheelShape, density: B.WHEEL.density, friction: B.WHEEL.friction, restitution: B.WHEEL.restitution, filterCategoryBits: CAT.BIKE });
      rwFix.setUserData({ type: 'wheel', which: 'rear' });
      fwFix.setUserData({ type: 'wheel', which: 'front' });

      // Helmet (sensor)
      const helmet = world.createDynamicBody({
        position: Vec2(p.x, p.y + 0.6 + (B.CHASSIS.h * 0.5) + B.HELMET.r + 0.05),
        fixedRotation: false,
      });
      helmet.createFixture({
        shape: pl.Circle(B.HELMET.r),
        isSensor: true,
        density: 0.01,
        filterCategoryBits: CAT.HELMET,
        filterMaskBits: 0xFFFF
      }).setUserData({ type: 'helmet' });

      // Joints
      const rearJoint = world.createJoint(pl.RevoluteJoint({
        enableMotor: true,
        maxMotorTorque: CONFIG.BIKE.MOTOR.maxTorque,
        motorSpeed: 0
      }, ch, rw, rw.getPosition()));

      const frontJoint = world.createJoint(pl.RevoluteJoint({
        enableMotor: true,
        maxMotorTorque: CONFIG.BIKE.MOTOR.maxTorque,
        motorSpeed: 0
      }, ch, fw, fw.getPosition()));

      this.chassis = ch;
      this.rear = rw;
      this.front = fw;
      this.helmet = helmet;
      this.rearJoint = rearJoint;
      this.frontJoint = frontJoint;

      // Ground contact flags + air/tilt state
      this.frontOnGround = false;
      this.rearOnGround  = false;
      this.airState = 'GROUND'; // 'GROUND' | 'AIR'
      this.airAirMs = 0;        // ms accumulated with both wheels off
      this.airGroundMs = 0;     // ms accumulated with any wheel touching
      this.tiltMag = 0;         // Nm magnitude ramp
      this.tiltAxis = 0;        // -1 (left/forward) | 0 | +1 (right/back)

      // Collision + wheel/ground contact flags
      const self = this;
      world.on('begin-contact', function(c) {
        const fa = c.getFixtureA(), fb = c.getFixtureB();
        const a = fa && fa.getUserData ? fa.getUserData() : null;
        const b = fb && fb.getUserData ? fb.getUserData() : null;
        if (!a || !b) return;

        // Wheel-ground flags (do NOT gate on invuln)
        if ((a.type === 'wheel' && b.type === 'ground') || (b.type === 'wheel' && a.type === 'ground')) {
          const wheel = (a.type === 'wheel') ? a : b;
          if (wheel.which === 'rear')  self.rearOnGround = true;
          if (wheel.which === 'front') self.frontOnGround = true;
        }

        // Crash detection (respect invulnerability timer)
        if (self.invulnTimer > 0) return;
        const types = [a.type, b.type];
        if ((types.includes('helmet') && types.includes('ground')) ||
            (types.includes('chassis') && types.includes('ground'))) {
          self.dead = true;
        }
      });

      world.on('end-contact', function(c) {
        const fa = c.getFixtureA(), fb = c.getFixtureB();
        const a = fa && fa.getUserData ? fa.getUserData() : null;
        const b = fb && fb.getUserData ? fb.getUserData() : null;
        if (!a || !b) return;

        if ((a.type === 'wheel' && b.type === 'ground') || (b.type === 'wheel' && a.type === 'ground')) {
          const wheel = (a.type === 'wheel') ? a : b;
          if (wheel.which === 'rear')  self.rearOnGround = false;
          if (wheel.which === 'front') self.frontOnGround = false;
        }
      });
    }

    setMotorSpeed(speed) {
      // Do not clamp here; clamping causes counter-torque (engine braking) on re-throttle
      if (this.rearJoint && this.rearJoint.setMotorSpeed) this.rearJoint.setMotorSpeed(speed);
      if (this.frontJoint && this.frontJoint.setMotorSpeed) this.frontJoint.setMotorSpeed(speed);
    }

    applyTiltTorque(dir, airborne) {
      // dir: -1 or +1
      const k = airborne ? 1.0 : 0.5; // less torque when grounded
      const torque = CONFIG.BIKE.CHASSIS_TILT_TORQUE * dir * k;
      this.chassis.applyTorque(torque, true);
    }

    getPos() {
      return this.chassis.getPosition();
    }

    getVel() {
      return this.chassis.getLinearVelocity();
    }

    isAirborne() {
      // Robust: driven by wheel contact flags with hysteresis (updated in fixedUpdate)
      return this.airState === 'AIR';
    }

    detachJoints() {
      try {
        if (this.rearJoint) { this.world.destroyJoint(this.rearJoint); this.rearJoint = null; }
        if (this.frontJoint) { this.world.destroyJoint(this.frontJoint); this.frontJoint = null; }
      } catch {}
    }

    destroy() {
      this.world.destroyBody(this.rear);
      this.world.destroyBody(this.front);
      this.world.destroyBody(this.helmet);
      this.world.destroyBody(this.chassis);
    }

    draw(camera) {
      const scale = CONFIG.SCALE;

      // Rider sprite (anchored to chassis)
      if (CONFIG.BIKE.SPRITE.show && riderLoaded) {
        const p = this.chassis.getPosition();
        const angle = this.chassis.getAngle();
        const sx = worldToScreenX(p.x, camera.x);
        const sy = worldToScreenY(p.y, camera.y);
        const spr = CONFIG.BIKE.SPRITE;
        const wpx = spr.widthMeters * scale;
        const ratio = (riderImg.width > 0) ? (riderImg.height / riderImg.width) : 1;
        const hpx = wpx * ratio;
        const ox = spr.offsetX * scale;
        const oy = spr.offsetY * scale;

        ctx.save();
        ctx.globalAlpha = Math.max(0, Math.min(1, playerAlpha));
        ctx.translate(sx, sy);
        ctx.rotate(-angle);
        if (spr.clipToChassis) {
          const hw = CONFIG.BIKE.CHASSIS.w * 0.5 * scale;
          const hh = CONFIG.BIKE.CHASSIS.h * 0.5 * scale;
          ctx.beginPath();
          ctx.rect(-hw, -hh, hw * 2, hh * 2);
          ctx.clip();
        }
        ctx.drawImage(riderImg, -wpx * 0.5 + ox, -hpx * 0.5 + oy, wpx, hpx);
        ctx.restore();
      }

      // Wheels (draw in front of sprite)
      drawCircleBody(this.rear, '#2b2b2b', '#1a1a1a');
      drawCircleBody(this.front, '#2b2b2b', '#1a1a1a');

      // Chassis (hide when sprite is shown unless debugging). During dying, force-hide structure.
      if ((CONFIG.DEBUG || !riderLoaded || !CONFIG.BIKE.SPRITE.show) && lifeState !== 'dying') {
        drawRectBody(this.chassis, CONFIG.BIKE.CHASSIS.w, CONFIG.BIKE.CHASSIS.h, '#2b6cb0', '#0a3d78');
      }

      // Helmet (sensor) visible only in debug (but hide during dying)
      if (CONFIG.DEBUG && lifeState !== 'dying') {
        drawCircleBody(this.helmet, '#ff4d4d', '#b31515');
      }

      // Link lines (debug style) — hide during dying
      if (CONFIG.DEBUG && lifeState !== 'dying') {
        drawLink(this.chassis, this.rear);
        drawLink(this.chassis, this.front);
      }

      // Helper draws
      function drawCircleBody(body, fill, stroke) {
        const p = body.getPosition();
        const angle = body.getAngle();
        const sx = worldToScreenX(p.x, camera.x);
        const sy = worldToScreenY(p.y, camera.y);
        let r = 0.45;
        // read first fixture radius if available
        const f = body.getFixtureList();
        if (f && f.getShape() && f.getShape().m_radius) {
          r = f.getShape().m_radius;
        }
        const rp = r * scale;

        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(-angle);
        ctx.beginPath();
        ctx.arc(0, 0, rp, 0, Math.PI * 2);
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.lineWidth = 3;
        ctx.strokeStyle = stroke;
        ctx.stroke();
        // spokes
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2;
        for (let i = 0; i < 6; i++) {
          const a = (Math.PI * 2 * i) / 6;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(a) * rp, Math.sin(a) * rp);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawRectBody(body, w, h, fill, stroke) {
        const p = body.getPosition();
        const angle = body.getAngle();
        const sx = worldToScreenX(p.x, camera.x);
        const sy = worldToScreenY(p.y, camera.y);
        const hw = w * 0.5 * scale;
        const hh = h * 0.5 * scale;

        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(-angle);
        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.rect(-hw, -hh, hw * 2, hh * 2);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }

      function drawLink(a, b) {
        const pa = a.getPosition();
        const pb = b.getPosition();
        const sx1 = worldToScreenX(pa.x, camera.x);
        const sy1 = worldToScreenY(pa.y, camera.y);
        const sx2 = worldToScreenX(pb.x, camera.x);
        const sy2 = worldToScreenY(pb.y, camera.y);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(sx1, sy1);
        ctx.lineTo(sx2, sy2);
        ctx.stroke();
      }

      function worldToScreenX(x, camX) {
        return Math.round(VIEW_W * 0.5 + (x - camX) * scale);
      }
      function worldToScreenY(y, camY) {
        return Math.round(VIEW_H * 0.5 - (y - camY) * scale);
      }
    }
  }

  // Utility: linear interpolation
  function lerp(a, b, t) { return a + (b - a) * t; }
  function approach(current, target, maxDelta) {
    if (current < target) return Math.min(target, current + maxDelta);
    return Math.max(target, current - maxDelta);
  }

  // Screen helpers for UI anchoring
  function worldToScreenXUI(x) {
    return Math.round(VIEW_W * 0.5 + (x - camera.x) * CONFIG.SCALE);
  }
  function worldToScreenYUI(y) {
    return Math.round(VIEW_H * 0.5 - (y - camera.y) * CONFIG.SCALE);
  }

  // Flip popup (toast) state
  const flipToast = { active: false, start: 0, duration: CONFIG.HUD.POPUP_MS, textHTML: '' };

  // Dot-product inverted detector (air-only; hysteresis)
  function updateInvertedDetector() {
    if (!flipSimple.air) return;
    const theta = bike.chassis.getAngle(); // radians
    const dot = Math.cos(theta);           // body-up · world-up

    if (!flipSimple.inverted) {
      // Try to enter inverted
      if (dot <= INV_ON && flipSimple.armed) {
        flipSimple.inverted = true;
        flipSimple.armed = false;      // lock while inverted
        flipSimple.flipCount += 1;     // COUNT 1 upside-down event
      }
    } else {
      // Try to exit inverted (unlock for next count)
      if (dot >= INV_OFF) {
        flipSimple.inverted = false;
        flipSimple.armed = true;
      }
    }
  }

  // Leaderboard (localStorage)
  const LB_KEY = 'moto2d_leaderboard';
  function loadLB() {
    try {
      const raw = localStorage.getItem(LB_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return [];
      // Migrate older entries {name, score, date} -> {name, distance, flip, total, date}
      const migrated = arr.map((e) => {
        if (e && typeof e === 'object' && ('total' in e)) return e;
        if (e && typeof e === 'object' && ('score' in e)) {
          const distance = Math.max(0, Math.floor(Number(e.score) || 0));
          const flip = 0;
          const total = distance;
          return { name: e.name || '???', distance, flip, total, date: e.date };
        }
        return e;
      });
      return migrated;
    } catch { return []; }
  }
  function saveLB(list) {
    try {
      // Always keep sorted by total descending before saving
      const sorted = (Array.isArray(list) ? list.slice() : []).sort((a, b) => (Number(b?.total)||0) - (Number(a?.total)||0));
      localStorage.setItem(LB_KEY, JSON.stringify(sorted.slice(0, 10)));
    } catch {}
  }
  function addScore(name, distance, flip, total) {
    const d = Math.max(0, Math.floor(Number(distance) || 0));
    const f = Math.max(0, Math.floor(Number(flip) || 0));
    const t = Math.max(0, Math.floor(Number(total) || (d + f)));
    const list = loadLB();
    list.push({ name, distance: d, flip: f, total: t, date: new Date().toISOString().slice(0,10) });
    // Sort by total desc
    list.sort((a, b) => (Number(b?.total)||0) - (Number(a?.total)||0));
    saveLB(list);
  }
  function renderLeaderboard() {
    const list = loadLB().slice().sort((a, b) => (Number(b?.total)||0) - (Number(a?.total)||0));
    leaderboardList.innerHTML = '';
    const header = document.createElement('div');
    header.className = 'lb-row header';
    header.style.gridTemplateColumns = '1.3fr 1fr 1fr 1fr';
    header.innerHTML = '<div>Name</div><div>Distance</div><div>Flip</div><div>Total</div>';
    leaderboardList.appendChild(header);
    list.forEach((row, idx) => {
      const distance = Math.max(0, Math.floor(Number(row?.distance) || 0));
      const flip = Math.max(0, Math.floor(Number(row?.flip) || 0));
      const total = Math.max(0, Math.floor(Number(row?.total) || (distance + flip)));
      const div = document.createElement('div');
      div.className = 'lb-row';
      div.style.gridTemplateColumns = '1.3fr 1fr 1fr 1fr';
      div.innerHTML = `<div>${idx + 1}. ${esc(row?.name || '')}</div><div>${distance}</div><div>${flip}</div><div>${total}</div>`;
      leaderboardList.appendChild(div);
    });
    if (list.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'center small';
      empty.style.padding = '12px 0';
      empty.textContent = 'No scores yet. Play a round!';
      leaderboardList.appendChild(empty);
    }
  }
  function esc(s) {
    return String(s || '').replace(/[&<>"']/g, c => ({'&':'&','<':'<','>':'>','"':'"'}[c] || c));
  }

  // Game State
  const STATE = {
    MENU: 'menu',
    PLAYING: 'playing',
    PAUSED: 'paused',
    GAMEOVER: 'gameover',
    LEADERBOARD: 'leaderboard'
  };

  let world = null;
  let terrain = null;
  let bike = null;
  let state = STATE.MENU;
  let seed = newSeed();

  // Life/respawn FSM
  let lifeState = 'alive'; // 'alive' | 'dying' | 'respawning' | 'gameover'
  let deathTimer = 0;
  let respawnTimer = 0;
  let playerAlpha = 1;
  let deathPos = null; // Vec2 in world coords
  let deathAngle = 0;

  let accumulator = 0;
  const fixedDt = 1 / CONFIG.FIXED_HZ;
  let lastTs = performance.now();

  // Scoring & lives & checkpoints
  let lives = CONFIG.MAX_LIVES;
  let maxXReached = 0; // meters (worldOffset adjusted)
  let invulnLeft = 0;
  let currentCheckpoint = { x: 0, y: 0 };
  let camera = { x: 0, y: 0 };
  let motorTarget = 0;
  let lastAxis = 0;
  let motorsEnabled = false;

  // Flip scoring accumulator
  let scoreFlip = 0;

  // Simple airborne flip detector (dot-product + hysteresis)
  const flipSimple = {
    air: false,            // true when BOTH wheels are off
    inverted: false,       // inside inverted cone
    armed: false,          // ready to count next entry into inverted
    flipCount: 0,          // flips in current airtime
    landArming: false,     // legacy (not used with two-touch)
    landStartMs: 0,
    lastCredited: 0,       // last validated flips (shown in HUD)
    landFrontSeen: false,  // has front wheel touched since takeoff
    landRearSeen: false    // has rear wheel touched since takeoff
  };

  // Image clouds (deterministic)
  const clouds = [];
  function initClouds(seedVal = seed) {
    clouds.length = 0;
    const rng = mulberry32((seedVal ^ 0x1234abcd) >>> 0);
    const N = CONFIG.CLOUDS.count;
    for (let i = 0; i < N; i++) {
      clouds.push({
        x: rng() * 300, // world-offset x basis
        y: 22 + rng() * 8, // higher band in the sky
        s: CONFIG.CLOUDS.scaleMin + rng() * (CONFIG.CLOUDS.scaleMax - CONFIG.CLOUDS.scaleMin),
        t: rng() < 0.5 ? 'c1' : 'c2' // choose sprite
      });
    }
  }

  function resetWorld(newRunSeed) {
    seed = newRunSeed || newSeed();
    world = new pl.World({ gravity: Vec2(0, -CONFIG.GRAVITY) });
    terrain = new Terrain(world, seed);
    lives = CONFIG.MAX_LIVES;
    maxXReached = 0;
    invulnLeft = 0;
    currentCheckpoint = { x: 0, y: 0 };
    camera = { x: 0, y: 0 };
    accumulator = 0;
    lastTs = performance.now();
    initClouds();

    // Initial flat ground to start (spawn a bit to the right of origin)
    // Optional quick-start parameter (?start=XXXX) to spawn near a given X for testing
    const params = new URLSearchParams(location.search);
    const startParam = parseFloat(params.get('start'));
    const spawnX = Number.isFinite(startParam) ? startParam : 5;

    terrain.ensureAhead(spawnX + 200, 0);
    // Prefer exact ground from generated chunk (post-smoothing), fallback to sampled noise
    let spawnChunk = null;
    for (const ch of terrain.chunks) {
      if (spawnX >= ch.xStart && spawnX <= ch.xEnd) { spawnChunk = ch; break; }
    }
    let cp = null;
    if (spawnChunk) {
      cp = terrain.findSafePointNearX(spawnChunk, spawnX); // returns slight +0.3m offset
    }
    if (!cp) {
      cp = { x: spawnX, y: terrain.sampleHeight(spawnX) + 0.3 };
    }
    currentCheckpoint = cp;
    // spawn bike with the same vertical offset as respawn to avoid intersecting ground
    bike = new Bike(world, { x: currentCheckpoint.x, y: currentCheckpoint.y + 0.6 });
    // Align camera to spawn to avoid any initial off-screen frame
    camera.x = bike.getPos().x + CONFIG.CAM.lookAhead;
    camera.y = bike.getPos().y;
    motorTarget = 0;
    bike.invulnTimer = CONFIG.INVULN_TIME;

    // Pre-generate some chunks ahead
    terrain.ensureAhead(terrain.generatedToX + 300, 0);
  }

  // Input handling
  window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    switch (e.key) {
      case 'ArrowUp': keys.up = true; break;
      case 'ArrowDown': keys.down = true; break;
      case 'ArrowLeft': keys.left = true; break;
      case 'ArrowRight': keys.right = true; break;
      case 'd': case 'D':
        CONFIG.DEBUG = !CONFIG.DEBUG; break;
      case 't': case 'T':
        if (CONFIG.DEBUG && state === STATE.PLAYING) { teleportToX(CONFIG.RECENTER_X - 2); }
        break;
      case 'g': case 'G':
        if (CONFIG.DEBUG && state === STATE.PLAYING) { const cur = bike ? bike.getPos().x : 0; teleportToX(cur + 500); }
        break;
      case 'Escape':
        if (state === STATE.PLAYING) {
          setState(STATE.PAUSED);
        } else if (state === STATE.PAUSED) {
          setState(STATE.PLAYING);
        }
        break;
    }
  });
  window.addEventListener('keyup', (e) => {
    switch (e.key) {
      case 'ArrowUp': keys.up = false; break;
      case 'ArrowDown': keys.down = false; break;
      case 'ArrowLeft': keys.left = false; break;
      case 'ArrowRight': keys.right = false; break;
    }
  });

  // UI handlers
  playBtn.onclick = () => {
    unlockAndPlay();
    if (engineEnabled && window.initEngineAudio) { try { window.initEngineAudio(); } catch {} }
    startNewGame();
  };
  leaderboardBtn.onclick = () => { showLeaderboard(); };
  lbBackBtn.onclick = () => { setState(STATE.MENU); };
  saveScoreBtn.onclick = () => { submitScoreAndHide(); };
  if (musicBtn) { updateMusicUI(); musicBtn.onclick = () => { unlockAndPlay(); toggleMusic(); }; }
  if (engineBtn) { updateEngineUI(); engineBtn.onclick = () => { unlockAndPlay(); toggleEngine(); }; }
  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      submitScoreAndHide();
    }
  });
  nameInput.addEventListener('input', () => {
    let v = nameInput.value.replace(/[^A-Za-z0-9]/g, '').toUpperCase().slice(0, 3);
    if (nameInput.value !== v) nameInput.value = v;
    saveScoreBtn.disabled = v.length === 0;
  });

  function startNewGame() {
    resetWorld(newSeed());
    // Reset death/respawn FSM and VFX
    lifeState = 'alive';
    deathTimer = 0;
    respawnTimer = 0;
    playerAlpha = 1;
    try { if (explosionFx) explosionFx.style.display = 'none'; } catch {}
    setState(STATE.PLAYING);
  }

  function showLeaderboard() {
    renderLeaderboard();
    setState(STATE.LEADERBOARD);
  }

  function setState(s) {
    state = s;
    menu.classList.toggle('hidden', s !== STATE.MENU);
    leaderboardView.classList.toggle('hidden', s !== STATE.LEADERBOARD);
    gameOver.classList.toggle('hidden', s !== STATE.GAMEOVER);

    // Reset explosion/FSM when going to Menu/Home
    if (s === STATE.MENU) {
      try { if (explosionFx) explosionFx.style.display = 'none'; } catch {}
      lifeState = 'alive';
      playerAlpha = 1;
      deathTimer = 0;
      respawnTimer = 0;
    }

    if (s === STATE.PLAYING || s === STATE.PAUSED) {
      hudBox.style.display = '';
    } else {
      hudBox.style.display = 'none';
    }
    {
      const scoreBox = document.getElementById('scoreBox');
      if (s === STATE.PLAYING || s === STATE.PAUSED) {
        if (scoreBox) scoreBox.style.display = '';
      } else {
        if (scoreBox) scoreBox.style.display = 'none';
      }
    }

    // Pause overlay UI
    if (s === STATE.PAUSED) {
      window.PauseUI?.open?.();
    } else {
      window.PauseUI?.close?.();
    }

    // Engine audio lifecycle: only active during PLAYING and when enabled
    if (s === STATE.PLAYING) {
      if (engineEnabled) {
        if (typeof window.initEngineAudio === 'function' && !EngineState) {
          try { window.initEngineAudio(); } catch {}
        }
        engineResumeIfNeeded();
      } else {
        engineMuteImmediate();
        engineSuspendIfSafe();
      }
    } else {
      // Any non-playing state: mute and suspend to save CPU
      engineMuteImmediate();
      engineSuspendIfSafe();
    }
    if (s === STATE.GAMEOVER) {
      // Do not auto-hide the name prompt here; onCrash() controls its visibility.
      // Just sync the Save button enabled state with current input.
      const v = (nameInput.value || '').replace(/[^A-Za-z0-9]/g, '').toUpperCase().slice(0, 3);
      saveScoreBtn.disabled = v.length === 0;
    }
  }

  // Pause modal UI: wiring and API
  window.PauseUI = (() => {
    const el = document.getElementById('pauseModal');
    const btnHome = document.getElementById('ccPauseHome');
    const btnRestart = document.getElementById('ccPauseRestart');
    const btnCont = document.getElementById('ccPauseContinue');

    function open(){ if(!el) return; el.classList.remove('hidden'); el.setAttribute('aria-hidden','false'); }
    function close(){ if(!el) return; el.classList.add('hidden'); el.setAttribute('aria-hidden','true'); }

    const clearKeys = () => {
      try {
        if (typeof keys === 'object' && keys) {
          keys.up = false; keys.down = false; keys.left = false; keys.right = false;
        }
      } catch {}
    };

    // Wire buttons to existing flows
    btnHome && btnHome.addEventListener('click', () => { close(); setState(STATE.MENU); });
    btnRestart && btnRestart.addEventListener('click', () => { close(); try { unlockAndPlay(); } catch {} startNewGame(); });
    btnCont && btnCont.addEventListener('click', () => { close(); clearKeys(); setState(STATE.PLAYING); });

    // Public API
    return { open, close };
  })();

  // Game loop
  function loop(ts) {
    requestAnimationFrame(loop);
    const dt = Math.min((ts - lastTs) / 1000, 0.1);
    lastTs = ts;

    // Clear canvas
    resizeCanvasToDisplaySize();

    drawBackground();

    switch (state) {
      case STATE.MENU:
      case STATE.LEADERBOARD:
      case STATE.GAMEOVER:
        // idle
        break;
      case STATE.PAUSED:
        // draw paused overlay on top of last frame: handled by overlays
        break;
      case STATE.PLAYING:
        update(dt);
        render();
        break;
    }
  }

  function update(dt) {
    if (!world || !bike) return;

    accumulator += dt;
    const steps = Math.min(5, Math.floor(accumulator / fixedDt));
    for (let i = 0; i < steps; i++) {
      fixedUpdate(fixedDt);
      accumulator -= fixedDt;
    }

    // Update procedural engine audio (only while playing; requires prior init after user gesture)
    if (state === STATE.PLAYING && engineEnabled && typeof window.updateEngineAudio === 'function') {
      // Telemetry
      const airborne = (bike.airState === 'AIR');
    if (lifeState === 'dying') { motorTarget = 0; }
      const wR = bike.rear.getAngularVelocity ? bike.rear.getAngularVelocity() : 0;
      const wF = bike.front.getAngularVelocity ? bike.front.getAngularVelocity() : 0;
      const wAvg = 0.5 * (wR + wF);
      const axis = (lifeState === 'dying') ? 0 : Math.sign((keys.right ? 1 : 0) + (keys.left ? -1 : 0));
      const v = bike.getVel();
      const speed_mps = Math.abs(v.x);
      try {
        window.updateEngineAudio(dt, { airborne, wAvg, motorTarget, axis, speed_mps });
      } catch {}
    }

    // Flip popup animation and positioning
    if (flipToast.active && flipPopup && bike) {
      const now = performance.now();
      const t = Math.max(0, Math.min(1, (now - flipToast.start) / (flipToast.duration || 3000)));
      if (t >= 1) {
        flipToast.active = false;
        flipPopup.style.display = 'none';
      } else {
        const p = bike.getPos();
        const sx = worldToScreenXUI(p.x);
        const sy = worldToScreenYUI(p.y + 1.2);
        const rise = Math.round(30 * t);
        const alpha = (1 - t);
        flipPopup.style.left = `${sx}px`;
        flipPopup.style.top = `${sy - 60 - rise}px`;
        flipPopup.style.opacity = `${alpha.toFixed(2)}`;
      }
    }
    // Life/respawn FSM/timers
    updateLifeFSM(dt);

    // Render at end
  }

  function fixedUpdate(dt) {
    // Clean, snappy, progressive drive (single ramp on motorTarget)
    // Update airborne state via wheel contact flags + hysteresis
    {
      // Strict gating: AIR only when BOTH wheels are off the ground, with hysteresis
      const Tt = (CONFIG.BIKE.TILT || {});
      const H = (typeof Tt.HYSTERESIS_MS === 'number') ? Tt.HYSTERESIS_MS : 80;
      const bothOff = (!bike.frontOnGround && !bike.rearOnGround);

      if (bothOff) {
        bike.airAirMs = Math.min(999, bike.airAirMs + dt * 1000);
        bike.airGroundMs = 0;
      } else {
        bike.airGroundMs = Math.min(999, bike.airGroundMs + dt * 1000);
        bike.airAirMs = 0;
      }

      if (bike.airState === 'GROUND' && bothOff && bike.airAirMs >= H) bike.airState = 'AIR';
      if (bike.airState === 'AIR' && !bothOff && bike.airGroundMs >= H) bike.airState = 'GROUND';
    }
    const airborne = (bike.airState === 'AIR');
    const dirFwd = -1; // negative motor speed drives right with current joint orientation
    const M = CONFIG.BIKE.MOTOR;
    const controlDisabled = (lifeState === 'dying');
    const axis = controlDisabled ? 0 : ((keys.right ? 1 : 0) + (keys.left ? -1 : 0)); // +1 forward, -1 reverse

    // Read wheel speeds
    const wR = bike.rear.getAngularVelocity ? bike.rear.getAngularVelocity() : 0;
    const wF = bike.front.getAngularVelocity ? bike.front.getAngularVelocity() : 0;
    const wAvg = 0.5 * (wR + wF);

    if (airborne || axis === 0) {
      // ---- COAST / AIR ----
      if (bike.rearJoint) bike.rearJoint.enableMotor(false);
      if (bike.frontJoint) bike.frontJoint.enableMotor(false);
      // tilt only in AIR (strict both-wheels-off). No ground tilt.
      if (airborne) {
        const T = (CONFIG.BIKE.TILT || {});
        const sign = (typeof T.SIGN === 'number') ? T.SIGN : 1;
        const axis = controlDisabled ? 0 : Math.sign((keys.right ? 1 : 0) + (keys.left ? -1 : 0));

        if (axis !== 0) {
          const MAX = (typeof T.MAX === 'number') ? T.MAX : 90.0;
          const ACC = (typeof T.ACCEL === 'number') ? T.ACCEL : 70.0;
          const BASE = (typeof T.BASE === 'number') ? T.BASE : 8.0;
          const gain = ACC * (1 - (bike.tiltMag / Math.max(1e-6, MAX))); // easing as we approach MAX
          bike.tiltMag = Math.min(MAX, bike.tiltMag + (gain + BASE) * dt);
        } else {
          const DEC = (typeof T.DECAY === 'number') ? T.DECAY : 110.0;
          bike.tiltMag = Math.max(0, bike.tiltMag - DEC * dt);
        }

        if (bike.tiltMag > 0) {
          const torque = bike.tiltMag * (axis * sign);
          bike.chassis.applyTorque(torque, true);
        }
      } else {
        const T = (CONFIG.BIKE.TILT || {});
        const DEC = (typeof T.DECAY === 'number') ? T.DECAY : 110.0;
        bike.tiltMag = Math.max(0, bike.tiltMag - DEC * dt);
      }
    } else {
      // ---- DRIVE ----
      if (bike.rearJoint) bike.rearJoint.enableMotor(true);
      if (bike.frontJoint) bike.frontJoint.enableMotor(true);

      // progressive target toward cap (or toward 0 when flipping)
      const desiredCap = (axis > 0 ? dirFwd : -dirFwd) * (M.speedLimit || 32.0);
      const targetSign = axis * dirFwd; // sign of desired motor direction
      const sameDir = (Math.sign(motorTarget || 0) === Math.sign(targetSign)) || Math.abs(motorTarget) < (M.EPS || 0.25);
      const step = ((sameDir ? (M.ACCEL || 28.0) : (M.BRAKE || 26.0)) * dt);
      const aim = sameDir ? desiredCap : 0;

      // Move motorTarget toward aim
      if (Math.abs(aim - motorTarget) <= step) motorTarget = aim;
      else motorTarget += Math.sign(aim - motorTarget) * step;

      // Never brake on re-throttle if downhill already faster
      const epsNB = (typeof M.epsNoBrake === 'number') ? M.epsNoBrake : 0.2;
      if ((wAvg * targetSign) > 0 && Math.abs(wAvg) > Math.abs(motorTarget) - epsNB) {
        motorTarget = wAvg;
      }

      const launch = Math.abs(wAvg) < ((M.LAUNCH_SPEED !== undefined) ? M.LAUNCH_SPEED : 4.0);
      const torqueNow = launch ? ((M.LAUNCH_TORQUE !== undefined) ? M.LAUNCH_TORQUE : 26.0) : (M.maxTorque || 90.0);
      bike.rearJoint && bike.rearJoint.setMaxMotorTorque && bike.rearJoint.setMaxMotorTorque(torqueNow);
      bike.frontJoint && bike.frontJoint.setMaxMotorTorque && bike.frontJoint.setMaxMotorTorque(torqueNow);
      bike.setMotorSpeed(motorTarget);   // truly unclamped
    }

    // Remember for next step
    lastAxis = axis;

    // Step physics
    world.step(dt, 8, 3);

    // Simple airborne flip detector and landing award (two-touch landing)
    {
      const bothOff = (!bike.frontOnGround && !bike.rearOnGround);

      // Takeoff
      if (bothOff && !flipSimple.air) {
        flipSimple.air = true;
        flipSimple.inverted = false;
        flipSimple.armed = true;        // allow counting first entry
        flipSimple.flipCount = 0;
        flipSimple.landArming = false;  // unused with two-touch but kept for compatibility
        flipSimple.landFrontSeen = false;
        flipSimple.landRearSeen = false;
      }

      // Count inverted entries only while in air
      updateInvertedDetector();

      // Two-touch landing: award as soon as both wheels have touched once since takeoff
      if (flipSimple.air) {
        if (bike.frontOnGround) flipSimple.landFrontSeen = true;
        if (bike.rearOnGround)  flipSimple.landRearSeen  = true;

        if (flipSimple.landFrontSeen && flipSimple.landRearSeen) {
          // CREDIT HERE: award flip score based on distance at validation
          const n = Math.max(0, flipSimple.flipCount | 0);
          if (lifeState === 'alive' && !bike.dead) {
            const base = Math.floor(maxXReached);
            let pct = 0;
            if (n >= 3) pct = 0.75;
            else if (n === 2) pct = 0.25;
            else if (n === 1) pct = 0.07;

            const gain = Math.round(base * pct);
            if (gain > 0) {
              scoreFlip += gain;
              // Setup popup
              flipToast.active = true;
              flipToast.start = performance.now();
              flipToast.duration = (CONFIG.HUD && CONFIG.HUD.POPUP_MS) || 3000;
              flipToast.textHTML = `Flip x${n} +${gain}`;
              if (flipPopup) {
                flipPopup.innerHTML = `<span class="hudlabel">FLIP</span> x${n} <span class="badge">+${gain}</span>`;
                flipPopup.style.display = 'block';
                flipPopup.style.opacity = '1';
              }
            }
            flipSimple.lastCredited = n;
          } else {
            // No award if not alive or if a crash occurred in this step
          }

          // Reset for next jump
          flipSimple.air = false;
          flipSimple.inverted = false;
          flipSimple.armed = false;
          flipSimple.flipCount = 0;
          flipSimple.landArming = false;
          flipSimple.landFrontSeen = false;
          flipSimple.landRearSeen = false;
        }
      } else {
        // not airborne: do nothing
      }
    }

    // Distance/score progression
    const pos = bike.getPos();
    // Hard snap guard: keep camera close to rider at all times
    {
      const desiredX = pos.x + CONFIG.CAM.lookAhead;
      const snapX = CONFIG.CAM.snapX || 50;
      const snapY = CONFIG.CAM.snapY || 25;
      if (!Number.isFinite(camera.x) || Math.abs(camera.x - desiredX) > snapX) camera.x = desiredX;
      if (!Number.isFinite(camera.y) || Math.abs(camera.y - pos.y) > snapY) camera.y = pos.y;
    }
    const absoluteX = terrain.worldOffsetX + pos.x;
    if (absoluteX > maxXReached) maxXReached = absoluteX;

    // Generate terrain ahead
    const viewAhead = 120; // meters ahead to ensure
    terrain.ensureAhead(pos.x + viewAhead, maxXReached);

    // Cull behind
    terrain.cullBehind(pos.x - 120, currentCheckpoint.x);

    // World recentering
    terrain.shiftWorldIfNeeded(pos.x, (shift) => {
      // Keep camera in sync with world origin shift to avoid pop-to-empty view
      camera.x += shift;
      // Safety snap if something went far off (e.g., after a big shift)
      const desired = pos.x + CONFIG.CAM.lookAhead;
      const snapX = CONFIG.CAM.snapX || 50;
      if (!Number.isFinite(camera.x) || Math.abs(camera.x - desired) > snapX) {
        camera.x = desired;
      }
      if (!Number.isFinite(camera.y)) camera.y = pos.y;
    });

    // Vertical recentering (downhill mode)
    terrain.shiftWorldYIfNeeded(pos.y, (dy) => {
      camera.y += dy;
      const snapY = CONFIG.CAM.snapY || 25;
      if (!Number.isFinite(camera.y) || Math.abs(camera.y - pos.y) > snapY) {
        camera.y = pos.y;
      }
    });

    // Camera follow (with failsafes)
    const camTargetX = pos.x + CONFIG.CAM.lookAhead;
    const snapX = CONFIG.CAM.snapX || 50;
    const snapY = CONFIG.CAM.snapY || 25;
    // If camera went invalid or drifted wildly, snap back immediately
    if (!Number.isFinite(camera.x) || !Number.isFinite(camera.y)) {
      camera.x = camTargetX;
      camera.y = pos.y;
    } else {
      if (Math.abs(camera.x - camTargetX) > snapX) camera.x = camTargetX;
      if (Math.abs(camera.y - pos.y) > snapY) camera.y = pos.y;
    }
    const camTargetY = lerp(camera.y, pos.y, CONFIG.CAM.yLag);
    camera.x = lerp(camera.x, camTargetX, CONFIG.CAM.xLag);
    camera.y = camTargetY;

    // Crash detection (helmet handled by contact)
    if (bike.dead) {
      onCrash();
      return;
    }

    // Fall into abyss (camera-relative, far below screen)
    {
      const scale = CONFIG.SCALE;
      const worldH = VIEW_H / Math.max(1e-6, scale);
      const killY = camera.y - worldH * 1.25; // 25% below screen bottom
      if (pos.y < killY) {
        onCrash();
        return;
      }
    }

    // Checkpoint update: ensure currentCheckpoint is the last one <= bike absolute x
    const absX = terrain.worldOffsetX + pos.x;
    while (terrain.checkpoints.length && (terrain.checkpoints[0].x + terrain.worldOffsetX) <= (absX - 1e6)) {
      // unlikely, but keep consistent
      terrain.checkpoints.shift();
    }
    // last passed checkpoint (x <= bike x)
    let passed = currentCheckpoint;
    for (let i = 0; i < terrain.checkpoints.length; i++) {
      const cp = terrain.checkpoints[i];
      if (cp.x <= pos.x) passed = cp; else break;
    }
    currentCheckpoint = passed;

    // HUD
    const v = bike.getVel();
    const speedKmh = Math.max(0, Math.round(Math.hypot(v.x, v.y) * 3.6));
    hudSpeed.textContent = `${speedKmh} km/h`;
    if (hudSpeedFill) {
      const vmax = (CONFIG.HUD && CONFIG.HUD.SPEED_MAX_KMH) || 120;
      const pct = Math.max(0, Math.min(1, speedKmh / Math.max(1, vmax)));
      hudSpeedFill.style.width = `${Math.round(pct * 100)}%`;
    }
    // Lives as hearts
    if (hudLives) {
      const full = Math.max(0, Math.min(CONFIG.MAX_LIVES, lives));
      const empty = Math.max(0, CONFIG.MAX_LIVES - full);
      hudLives.textContent = '❤️'.repeat(full) + '🤍'.repeat(empty);
    }
    // Scores (right HUD)
    const scoreDistance = Math.floor(maxXReached);
    const totalScore = scoreDistance + scoreFlip;
    if (scoreDistEl) scoreDistEl.textContent = `${scoreDistance}`;
    if (scoreFlipEl) scoreFlipEl.textContent = `${scoreFlip}`;
    if (scoreTotalEl) scoreTotalEl.textContent = `${totalScore}`;

    // Invulnerability timer
    if (bike.invulnTimer > 0) bike.invulnTimer -= dt;
  }

  // Death/Respawn finite-state machine
  function updateExplosionFxPosition() {
    if (!explosionFx || !deathPos) return;
    const sx = worldToScreenXUI(deathPos.x);
    const sy = worldToScreenYUI(deathPos.y);
    const w = (CONFIG.BIKE.SPRITE.widthMeters || 2.4) * CONFIG.SCALE * 1.5;
    explosionFx.style.width = `${Math.round(w)}px`;
    explosionFx.style.left = `${sx}px`;
    explosionFx.style.top = `${sy}px`;
  }

  function restartExplosionGif() {
    if (!explosionFx) return;
    const old = explosionFx;
    const clone = old.cloneNode(false); // keep id/attrs
    if (old.parentNode) {
      old.parentNode.replaceChild(clone, old);
    }
    explosionFx = clone;
    // keep hidden until we explicitly show on death
    explosionFx.style.display = 'none';
  }

  function beginDying() {
    // Enter dying state only from alive
    lifeState = 'dying';
    const R = CONFIG.RESPAWN || {};
    deathTimer = (R.EXPLOSION_MS ? R.EXPLOSION_MS : 2000) / 1000;
    playerAlpha = 1;

    // Capture death position/angle
    try {
      if (bike && bike.chassis) {
        const p = bike.chassis.getPosition();
        deathPos = Vec2(p.x, p.y);
        deathAngle = bike.chassis.getAngle();
        // Damp motion: zero velocities once
        bike.chassis.setLinearVelocity(Vec2(0, 0));
        bike.chassis.setAngularVelocity(0);
        bike.rear.setLinearVelocity(Vec2(0, 0));
        bike.front.setLinearVelocity(Vec2(0, 0));
        bike.rear.setAngularVelocity(0);
        bike.front.setAngularVelocity(0);
      }
    } catch {}

    // Show explosion (restart GIF to frame 0)
    restartExplosionGif();
    if (explosionFx) {
      explosionFx.style.display = 'block';
      updateExplosionFxPosition();
    }

    // Detach wheel joints so wheels are free to roll/bounce visually
    try { if (bike && bike.detachJoints) bike.detachJoints(); } catch {}
    // Hard-cancel any flip state on death (double safety)
    try {
      flipSimple.air = false;
      flipSimple.inverted = false;
      flipSimple.armed = false;
      flipSimple.flipCount = 0;
      flipSimple.landArming = false;
      flipSimple.landFrontSeen = false;
      flipSimple.landRearSeen = false;
    } catch {}

    // Mute engine during dying
    try { engineMuteImmediate(); engineSuspendIfSafe(); } catch {}
  }

  function updateLifeFSM(dt) {
    const R = CONFIG.RESPAWN || {};
    if (lifeState === 'dying') {
      deathTimer -= dt;
      const deathTotal = (R.EXPLOSION_MS ? R.EXPLOSION_MS : 2000) / 1000;
      const fadeOutSec = (R.FADE_OUT_MS ? R.FADE_OUT_MS : 500) / 1000;
      const elapsed = Math.max(0, Math.min(deathTotal, deathTotal - Math.max(0, deathTimer)));
      if (elapsed <= fadeOutSec) {
        playerAlpha = Math.max(0, 1 - (elapsed / Math.max(1e-6, fadeOutSec)));
      } else {
        playerAlpha = 0;
      }
      // Keep explosion anchored to captured deathPos
      updateExplosionFxPosition();

      if (deathTimer <= 0) {
        // Hide explosion
        if (explosionFx) explosionFx.style.display = 'none';
        // Reset GIF to frame 0 while hidden so next death starts from the beginning
        restartExplosionGif();

        if (CONFIG.DEBUG === true || lives > 0) {
          // Respawn above checkpoint
          const cp = currentCheckpoint || { x: 0, y: 0 };
          // Ensure visuals/terrain around the checkpoint before respawn
          terrain.rebuildAllGfx && terrain.rebuildAllGfx();
          terrain.ensureAhead(cp.x + 120, maxXReached);
          if (!terrain.hasGfxNear(cp.x, CONFIG.CHUNK_LENGTH)) {
            terrain.rebuildAllGfx && terrain.rebuildAllGfx();
            terrain.ensureAhead(cp.x + 2 * CONFIG.CHUNK_LENGTH, maxXReached);
          }
          if (bike) bike.destroy();
          const above = (typeof R.ABOVE_CHECKPOINT_M === 'number') ? R.ABOVE_CHECKPOINT_M : 3.5;
          const xSpawn = cp.x - 0.3;
          const ySpawn = cp.y + above;
          bike = new Bike(world, { x: xSpawn, y: ySpawn });
          // Zero velocities at spawn
          bike.chassis.setLinearVelocity(Vec2(0, 0));
          bike.chassis.setAngularVelocity(0);
          bike.rear.setLinearVelocity(Vec2(0, 0));
          bike.front.setLinearVelocity(Vec2(0, 0));
          bike.rear.setAngularVelocity(0);
          bike.front.setAngularVelocity(0);

          motorTarget = 0;
          // Invuln window
          bike.invulnTimer = CONFIG.INVULN_TIME;

          // Fade in while falling
          playerAlpha = 0;
          respawnTimer = (R.FADE_IN_MS ? R.FADE_IN_MS : 1000) / 1000;
          lifeState = 'respawning';

          // Resume engine audio if enabled
          if (engineEnabled) {
            try { engineResumeIfNeeded(); } catch {}
          }
        } else {
          // Final death -> Game Over overlay
          lifeState = 'gameover';
          playerAlpha = 0;

          // Prepare final score and overlay
          finalScoreText.textContent = `Score: ${Math.floor(maxXReached)} m`;
          const lb = loadLB();
          const qualifies = lb.length < 10 || maxXReached > (lb[lb.length - 1]?.score || 0);
          if (qualifies) {
            namePrompt.classList.remove('hidden');
            saveScoreBtn.classList.remove('hidden');
            nameInput.value = '';
            saveScoreBtn.disabled = true;
            setTimeout(() => nameInput.focus(), 0);
            setState(STATE.GAMEOVER);
          } else {
            namePrompt.classList.add('hidden');
            saveScoreBtn.classList.add('hidden');
            renderLeaderboard();
            setState(STATE.LEADERBOARD);
          }
        }
      }
    } else if (lifeState === 'respawning') {
      const total = (R.FADE_IN_MS ? R.FADE_IN_MS : 1000) / 1000;
      respawnTimer -= dt;
      const elapsed = Math.max(0, Math.min(total, total - Math.max(0, respawnTimer)));
      playerAlpha = Math.max(0, Math.min(1, elapsed / Math.max(1e-6, total)));
      if (respawnTimer <= 0) {
        playerAlpha = 1;
        lifeState = 'alive';
      }
    } else if (lifeState === 'alive') {
      playerAlpha = 1;
    } else if (lifeState === 'gameover') {
      // keep alpha at 0 until leaving
      playerAlpha = 0;
    }
  }

  function onCrash() {
    // Guard: ignore repeated crashes during dying/respawning/gameover
    if (lifeState !== 'alive') {
      try { if (bike) bike.dead = false; } catch {}
      return;
    }
    // Cancel any in-air flip counting and popup on death
    try {
      flipSimple.air = false;
      flipSimple.inverted = false;
      flipSimple.armed = false;
      flipSimple.flipCount = 0;
      flipSimple.landArming = false;
      flipSimple.landFrontSeen = false;
      flipSimple.landRearSeen = false;
    } catch {}
    try {
      if (typeof flipToast !== 'undefined' && flipToast) flipToast.active = false;
      if (typeof flipPopup !== 'undefined' && flipPopup) {
        flipPopup.style.display = 'none';
        flipPopup.style.opacity = '0';
        flipPopup.innerHTML = '';
      }
    } catch {}
    const ignoreLives = CONFIG.DEBUG === true;
    if (!ignoreLives) {
      lives--;
    }
    // Begin dying sequence; final Game Over handled after explosion
    if (lifeState !== 'alive') return;
    try { if (bike) bike.dead = false; } catch {}
    beginDying();
    return;
    if (ignoreLives || lives > 0) {
      // Respawn
      const cp = currentCheckpoint;
      const y = cp.y + 0.6;
      // Ensure visuals/terrain around the checkpoint before respawn
      terrain.rebuildAllGfx && terrain.rebuildAllGfx();
      terrain.ensureAhead(cp.x + 120, maxXReached);
      if (!terrain.hasGfxNear(cp.x, CONFIG.CHUNK_LENGTH)) {
        terrain.rebuildAllGfx();
        terrain.ensureAhead(cp.x + 2 * CONFIG.CHUNK_LENGTH, maxXReached);
      }
      // Remove existing bike
      if (bike) bike.destroy();
      // Nudge slightly behind the checkpoint to avoid spawning exactly on a lip
      const xSpawn = cp.x - 0.3;
      bike = new Bike(world, { x: xSpawn, y: y });
      motorTarget = 0;
      bike.invulnTimer = CONFIG.INVULN_TIME;
    } else {
      // Game Over
      finalScoreText.textContent = `Score: ${Math.floor(maxXReached)} m`;
      // If top 10 or if list less than 10, prompt for name; otherwise go straight to leaderboard
      const lb = loadLB();
      const qualifies = lb.length < 10 || maxXReached > (lb[lb.length - 1]?.score || 0);
      if (qualifies) {
        namePrompt.classList.remove('hidden');
        saveScoreBtn.classList.remove('hidden');
        nameInput.value = '';
        saveScoreBtn.disabled = true;
        setTimeout(() => nameInput.focus(), 0);
        setState(STATE.GAMEOVER);
      } else {
        namePrompt.classList.add('hidden');
        saveScoreBtn.classList.add('hidden');
        renderLeaderboard();
        setState(STATE.LEADERBOARD);
      }
    }
  }

  function submitScoreAndHide() {
    let raw = (nameInput.value || '').trim();
    raw = raw.replace(/[^A-Za-z0-9]/g, '').toUpperCase().slice(0, 3);
    if (!raw) {
      // Require a non-empty initials before saving
      namePrompt.classList.remove('hidden');
      saveScoreBtn.classList.remove('hidden');
      saveScoreBtn.disabled = true;
      setTimeout(() => nameInput.focus(), 0);
      return;
    }
    const distance = Math.floor(maxXReached);
    const flip = Math.max(0, scoreFlip | 0);
    const total = distance + flip;
    addScore(raw, distance, flip, total);
    namePrompt.classList.add('hidden');
    saveScoreBtn.classList.add('hidden');
    renderLeaderboard(); // update
    setState(STATE.LEADERBOARD);
  }

  // Debug teleport helpers: compute ground height and respawn bike at new X
  function groundYAt(x) {
    for (const ch of terrain.chunks) {
      for (const g of ch.gfx) {
        const pts = g.pts;
        for (let i = 1; i < pts.length; i++) {
          const a = pts[i - 1], b = pts[i];
          if (x >= a.x && x <= b.x) {
            const t = (x - a.x) / Math.max(1e-6, (b.x - a.x));
            return a.y + (b.y - a.y) * t;
          }
        }
      }
    }
    return terrain.sampleHeight(x);
  }

  function teleportToX(x) {
    if (!world || !terrain) return;
    terrain.ensureAhead(x + 120, maxXReached);
    // Choose a safe point near x when possible
    let chunk = null;
    for (const ch of terrain.chunks) { if (x >= ch.xStart && x <= ch.xEnd) { chunk = ch; break; } }
    const cp = chunk ? (terrain.findSafePointNearX(chunk, x) || { x, y: groundYAt(x) + 0.3 }) : { x, y: groundYAt(x) + 0.3 };
    currentCheckpoint = cp;
    if (bike) bike.destroy();
    bike = new Bike(world, { x: cp.x, y: cp.y + 0.6 });
    motorTarget = 0;
    bike.invulnTimer = CONFIG.INVULN_TIME;
    camera.x = bike.getPos().x + CONFIG.CAM.lookAhead;
    camera.y = bike.getPos().y;
  }

  function render() {
    // Terrain and bike
    terrain.draw(camera);
    bike.draw(camera);

    // Clouds (parallax)
    drawClouds();
  }

  function drawBackground() {
    // Sky gradient already in CSS; draw subtle horizon
    const g = ctx.createLinearGradient(0, 0, 0, VIEW_H);
    g.addColorStop(0, '#78c8ff');
    g.addColorStop(0.6, '#bde1ff');
    g.addColorStop(1, '#e6f6ff');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, VIEW_W, VIEW_H);
  }

  function drawClouds() {
    const par = CONFIG.CLOUDS.parallax;
    for (const c of clouds) {
      const img = (c.t === 'c2' && cloud2Img.complete) ? cloud2Img : cloudImg;
      if (!img.complete) continue;
      const wx = c.x + (terrain.worldOffsetX + camera.x) * par;
      const sx = Math.round((wx % 200) / 200 * VIEW_W);
      // place higher and smaller
      const sy = Math.round(VIEW_H * 0.12 + (c.y - 22) * 8);
      const w = img.width * c.s * 0.30;
      const h = img.height * c.s * 0.30;
      ctx.drawImage(img, sx - w * 0.5, sy - h * 0.5, w, h);
    }
  }

  function resizeCanvasToDisplaySize() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    const dpr = window.devicePixelRatio || 1;
    VIEW_W = w;
    VIEW_H = h;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    const needResize = canvas.width !== Math.round(w * dpr) || canvas.height !== Math.round(h * dpr);
    if (needResize) {
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
    }
    // scale drawing ops so our coordinates are in CSS pixels
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
  }

  // Start in menu
  setState(STATE.MENU);
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
